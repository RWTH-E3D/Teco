<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>teaser.data.surfacegml API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>teaser.data.surfacegml</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from numpy import linalg as LA


class SurfaceGML(object):
    &#34;&#34;&#34;Class for calculating attributes of CityGML surfaces

    this class automatically calculates surface area using an algorithm for
    polygons with arbitrary number of points. The Surface orientation by
    analysing the normal vector (caution: the orientations are then set to
    TEASER orientation). The Surface tilt by analysing the normal vector.

    Parameters
    ----------

    gml_surface : list
        list of gml points with srsDimension=3 the first 3 and the last 3
        entries must describe the same point in CityGML

    boundary : str
        Name of the boundary surface

    &#34;&#34;&#34;

    def __init__(self,
                 gml_surface,
                 boundary=None):
        self.gml_surface = gml_surface
        self.name = boundary
        self.surface_area = None
        self.surface_orientation = None
        self.surface_tilt = None

        self.surface_area = self.get_gml_area()
        self.surface_orientation = self.get_gml_orientation()
        self.surface_tilt = self.get_gml_tilt()

    def get_gml_area(self):
        &#34;&#34;&#34;calc the area of a gml_surface defined by gml coordinates

        Surface needs to be planar

        Returns
        ----------
        surface_area : float
            returns the area of the surface
        &#34;&#34;&#34;

        split_surface = list(zip(*[iter(self.gml_surface)] * 3))
        self.surface_area = self.poly_area(poly=split_surface)
        return self.surface_area

    def get_gml_tilt(self):
        &#34;&#34;&#34;calc the tilt of a gml_surface defined by 4 or 5 gml coordinates

        Surface needs to be planar

        Returns
        ----------
        surface_tilt : float
            returns the orientation of the surface
        &#34;&#34;&#34;

        gml_surface = np.array(self.gml_surface)
        gml1 = gml_surface[0:3]
        gml2 = gml_surface[3:6]
        gml3 = gml_surface[6:9]

        vektor_1 = gml2 - gml1
        vektor_2 = gml3 - gml1

        normal_1 = np.cross(vektor_1, vektor_2)
        z_axis = np.array([0, 0, 1])

        self.surface_tilt = np.arccos(np.dot(normal_1, z_axis) / (LA.norm(
            z_axis) * LA.norm(normal_1))) * 360 / (2 * np.pi)

        if self.surface_tilt == 180:
            self.surface_tilt = 0.0
        elif str(self.surface_tilt) == &#34;nan&#34;:
            self.surface_tilt = None
        return self.surface_tilt

    def get_gml_orientation(self):
        &#34;&#34;&#34;calc the orientation of a gml_surface defined by 4 or 5 gml
        coordinates

        Surface needs to be planar, the orientation returned is in TEASER
        coordinates

        Returns
        ----------
        surface_orientation : float
            returns the orientation of the surface
        &#34;&#34;&#34;

        gml_surface = np.array(self.gml_surface)
        gml1 = gml_surface[0:3]
        gml2 = gml_surface[3:6]
        gml3 = gml_surface[6:9]
        gml4 = gml_surface[9:12]
        if len(gml_surface) &gt; 12:
            vektor_1 = gml2 - gml1
            vektor_2 = gml4 - gml1
        else:
            vektor_1 = gml2 - gml1
            vektor_2 = gml3 - gml1

        normal_1 = np.cross(vektor_1, vektor_2)
        normal_uni = normal_1 / LA.norm(normal_1)
        phi = None
        if normal_uni[0] &gt; 0:
            phi = np.arctan(normal_uni[1] / normal_uni[0])
        elif normal_uni[0] &lt; 0 &lt;= normal_uni[1]:
            phi = np.arctan(normal_uni[1] / normal_uni[0]) + np.pi
        elif normal_uni[0] &lt; 0 &gt; normal_uni[1]:
            phi = np.arctan(normal_uni[1] / normal_uni[0]) - np.pi
        elif normal_uni[0] == 0 &lt; normal_uni[1]:
            phi = np.pi / 2
        elif normal_uni[0] == 0 &gt; normal_uni[1]:
            phi = -np.pi / 2

        if phi is None:
            pass
        elif phi &lt; 0:
            self.surface_orientation = (phi + 2 * np.pi) * 360 / (2 * np.pi)
        else:
            self.surface_orientation = phi * 360 / (2 * np.pi)

        if self.surface_orientation is None:
            pass
        elif 0 &lt;= self.surface_orientation &lt;= 90:
            self.surface_orientation = 90 - self.surface_orientation
        else:
            self.surface_orientation = 450 - self.surface_orientation

        if normal_uni[2] == -1:
            self.surface_orientation = -2
        elif normal_uni[2] == 1:
            self.surface_orientation = -1
        return self.surface_orientation

    def unit_normal(self, a, b, c):
        &#34;&#34;&#34;calculates the unit normal vector of a surface described by 3 points

        Parameters
        ----------

        a : float
            point 1
        b : float
            point 2
        c : float
            point 3

        Returns
        ----------

        unit_normal : list
            unit normal vector as a list

        &#34;&#34;&#34;

        x = np.linalg.det([[1, a[1], a[2]],
                           [1, b[1], b[2]],
                           [1, c[1], c[2]]])
        y = np.linalg.det([[a[0], 1, a[2]],
                           [b[0], 1, b[2]],
                           [c[0], 1, c[2]]])
        z = np.linalg.det([[a[0], a[1], 1],
                           [b[0], b[1], 1],
                           [c[0], c[1], 1]])
        magnitude = (x**2 + y**2 + z**2)**.5
        return x / magnitude, y / magnitude, z / magnitude

    def poly_area(self, poly):
        &#34;&#34;&#34;calculates the area of a polygon with arbitrary points

        Parameters
        ----------

        poly : list
            polygon as a list in srsDimension = 3

        Returns
        ----------

        area : float
            returns the area of a polygon
        &#34;&#34;&#34;

        if len(poly) &lt; 3:  # not a plane - no area
            return 0
        total = [0, 0, 0]
        length = len(poly)
        for i in range(length):
            vi1 = poly[i]
            vi2 = poly[(i + 1) % length]
            prod = np.cross(vi1, vi2)
            total[0] += prod[0]
            total[1] += prod[1]
            total[2] += prod[2]
        result = np.dot(total, self.unit_normal(poly[0], poly[1], poly[2]))
        return abs(result / 2)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="teaser.data.surfacegml.SurfaceGML"><code class="flex name class">
<span>class <span class="ident">SurfaceGML</span></span>
<span>(</span><span>gml_surface, boundary=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for calculating attributes of CityGML surfaces</p>
<p>this class automatically calculates surface area using an algorithm for
polygons with arbitrary number of points. The Surface orientation by
analysing the normal vector (caution: the orientations are then set to
TEASER orientation). The Surface tilt by analysing the normal vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gml_surface</code></strong> :&ensp;<code>list</code></dt>
<dd>list of gml points with srsDimension=3 the first 3 and the last 3
entries must describe the same point in CityGML</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the boundary surface</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SurfaceGML(object):
    &#34;&#34;&#34;Class for calculating attributes of CityGML surfaces

    this class automatically calculates surface area using an algorithm for
    polygons with arbitrary number of points. The Surface orientation by
    analysing the normal vector (caution: the orientations are then set to
    TEASER orientation). The Surface tilt by analysing the normal vector.

    Parameters
    ----------

    gml_surface : list
        list of gml points with srsDimension=3 the first 3 and the last 3
        entries must describe the same point in CityGML

    boundary : str
        Name of the boundary surface

    &#34;&#34;&#34;

    def __init__(self,
                 gml_surface,
                 boundary=None):
        self.gml_surface = gml_surface
        self.name = boundary
        self.surface_area = None
        self.surface_orientation = None
        self.surface_tilt = None

        self.surface_area = self.get_gml_area()
        self.surface_orientation = self.get_gml_orientation()
        self.surface_tilt = self.get_gml_tilt()

    def get_gml_area(self):
        &#34;&#34;&#34;calc the area of a gml_surface defined by gml coordinates

        Surface needs to be planar

        Returns
        ----------
        surface_area : float
            returns the area of the surface
        &#34;&#34;&#34;

        split_surface = list(zip(*[iter(self.gml_surface)] * 3))
        self.surface_area = self.poly_area(poly=split_surface)
        return self.surface_area

    def get_gml_tilt(self):
        &#34;&#34;&#34;calc the tilt of a gml_surface defined by 4 or 5 gml coordinates

        Surface needs to be planar

        Returns
        ----------
        surface_tilt : float
            returns the orientation of the surface
        &#34;&#34;&#34;

        gml_surface = np.array(self.gml_surface)
        gml1 = gml_surface[0:3]
        gml2 = gml_surface[3:6]
        gml3 = gml_surface[6:9]

        vektor_1 = gml2 - gml1
        vektor_2 = gml3 - gml1

        normal_1 = np.cross(vektor_1, vektor_2)
        z_axis = np.array([0, 0, 1])

        self.surface_tilt = np.arccos(np.dot(normal_1, z_axis) / (LA.norm(
            z_axis) * LA.norm(normal_1))) * 360 / (2 * np.pi)

        if self.surface_tilt == 180:
            self.surface_tilt = 0.0
        elif str(self.surface_tilt) == &#34;nan&#34;:
            self.surface_tilt = None
        return self.surface_tilt

    def get_gml_orientation(self):
        &#34;&#34;&#34;calc the orientation of a gml_surface defined by 4 or 5 gml
        coordinates

        Surface needs to be planar, the orientation returned is in TEASER
        coordinates

        Returns
        ----------
        surface_orientation : float
            returns the orientation of the surface
        &#34;&#34;&#34;

        gml_surface = np.array(self.gml_surface)
        gml1 = gml_surface[0:3]
        gml2 = gml_surface[3:6]
        gml3 = gml_surface[6:9]
        gml4 = gml_surface[9:12]
        if len(gml_surface) &gt; 12:
            vektor_1 = gml2 - gml1
            vektor_2 = gml4 - gml1
        else:
            vektor_1 = gml2 - gml1
            vektor_2 = gml3 - gml1

        normal_1 = np.cross(vektor_1, vektor_2)
        normal_uni = normal_1 / LA.norm(normal_1)
        phi = None
        if normal_uni[0] &gt; 0:
            phi = np.arctan(normal_uni[1] / normal_uni[0])
        elif normal_uni[0] &lt; 0 &lt;= normal_uni[1]:
            phi = np.arctan(normal_uni[1] / normal_uni[0]) + np.pi
        elif normal_uni[0] &lt; 0 &gt; normal_uni[1]:
            phi = np.arctan(normal_uni[1] / normal_uni[0]) - np.pi
        elif normal_uni[0] == 0 &lt; normal_uni[1]:
            phi = np.pi / 2
        elif normal_uni[0] == 0 &gt; normal_uni[1]:
            phi = -np.pi / 2

        if phi is None:
            pass
        elif phi &lt; 0:
            self.surface_orientation = (phi + 2 * np.pi) * 360 / (2 * np.pi)
        else:
            self.surface_orientation = phi * 360 / (2 * np.pi)

        if self.surface_orientation is None:
            pass
        elif 0 &lt;= self.surface_orientation &lt;= 90:
            self.surface_orientation = 90 - self.surface_orientation
        else:
            self.surface_orientation = 450 - self.surface_orientation

        if normal_uni[2] == -1:
            self.surface_orientation = -2
        elif normal_uni[2] == 1:
            self.surface_orientation = -1
        return self.surface_orientation

    def unit_normal(self, a, b, c):
        &#34;&#34;&#34;calculates the unit normal vector of a surface described by 3 points

        Parameters
        ----------

        a : float
            point 1
        b : float
            point 2
        c : float
            point 3

        Returns
        ----------

        unit_normal : list
            unit normal vector as a list

        &#34;&#34;&#34;

        x = np.linalg.det([[1, a[1], a[2]],
                           [1, b[1], b[2]],
                           [1, c[1], c[2]]])
        y = np.linalg.det([[a[0], 1, a[2]],
                           [b[0], 1, b[2]],
                           [c[0], 1, c[2]]])
        z = np.linalg.det([[a[0], a[1], 1],
                           [b[0], b[1], 1],
                           [c[0], c[1], 1]])
        magnitude = (x**2 + y**2 + z**2)**.5
        return x / magnitude, y / magnitude, z / magnitude

    def poly_area(self, poly):
        &#34;&#34;&#34;calculates the area of a polygon with arbitrary points

        Parameters
        ----------

        poly : list
            polygon as a list in srsDimension = 3

        Returns
        ----------

        area : float
            returns the area of a polygon
        &#34;&#34;&#34;

        if len(poly) &lt; 3:  # not a plane - no area
            return 0
        total = [0, 0, 0]
        length = len(poly)
        for i in range(length):
            vi1 = poly[i]
            vi2 = poly[(i + 1) % length]
            prod = np.cross(vi1, vi2)
            total[0] += prod[0]
            total[1] += prod[1]
            total[2] += prod[2]
        result = np.dot(total, self.unit_normal(poly[0], poly[1], poly[2]))
        return abs(result / 2)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="teaser.data.surfacegml.SurfaceGML.get_gml_area"><code class="name flex">
<span>def <span class="ident">get_gml_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>calc the area of a gml_surface defined by gml coordinates</p>
<p>Surface needs to be planar</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>surface_area</code></strong> :&ensp;<code>float</code></dt>
<dd>returns the area of the surface</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gml_area(self):
    &#34;&#34;&#34;calc the area of a gml_surface defined by gml coordinates

    Surface needs to be planar

    Returns
    ----------
    surface_area : float
        returns the area of the surface
    &#34;&#34;&#34;

    split_surface = list(zip(*[iter(self.gml_surface)] * 3))
    self.surface_area = self.poly_area(poly=split_surface)
    return self.surface_area</code></pre>
</details>
</dd>
<dt id="teaser.data.surfacegml.SurfaceGML.get_gml_orientation"><code class="name flex">
<span>def <span class="ident">get_gml_orientation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>calc the orientation of a gml_surface defined by 4 or 5 gml
coordinates</p>
<p>Surface needs to be planar, the orientation returned is in TEASER
coordinates</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>surface_orientation</code></strong> :&ensp;<code>float</code></dt>
<dd>returns the orientation of the surface</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gml_orientation(self):
    &#34;&#34;&#34;calc the orientation of a gml_surface defined by 4 or 5 gml
    coordinates

    Surface needs to be planar, the orientation returned is in TEASER
    coordinates

    Returns
    ----------
    surface_orientation : float
        returns the orientation of the surface
    &#34;&#34;&#34;

    gml_surface = np.array(self.gml_surface)
    gml1 = gml_surface[0:3]
    gml2 = gml_surface[3:6]
    gml3 = gml_surface[6:9]
    gml4 = gml_surface[9:12]
    if len(gml_surface) &gt; 12:
        vektor_1 = gml2 - gml1
        vektor_2 = gml4 - gml1
    else:
        vektor_1 = gml2 - gml1
        vektor_2 = gml3 - gml1

    normal_1 = np.cross(vektor_1, vektor_2)
    normal_uni = normal_1 / LA.norm(normal_1)
    phi = None
    if normal_uni[0] &gt; 0:
        phi = np.arctan(normal_uni[1] / normal_uni[0])
    elif normal_uni[0] &lt; 0 &lt;= normal_uni[1]:
        phi = np.arctan(normal_uni[1] / normal_uni[0]) + np.pi
    elif normal_uni[0] &lt; 0 &gt; normal_uni[1]:
        phi = np.arctan(normal_uni[1] / normal_uni[0]) - np.pi
    elif normal_uni[0] == 0 &lt; normal_uni[1]:
        phi = np.pi / 2
    elif normal_uni[0] == 0 &gt; normal_uni[1]:
        phi = -np.pi / 2

    if phi is None:
        pass
    elif phi &lt; 0:
        self.surface_orientation = (phi + 2 * np.pi) * 360 / (2 * np.pi)
    else:
        self.surface_orientation = phi * 360 / (2 * np.pi)

    if self.surface_orientation is None:
        pass
    elif 0 &lt;= self.surface_orientation &lt;= 90:
        self.surface_orientation = 90 - self.surface_orientation
    else:
        self.surface_orientation = 450 - self.surface_orientation

    if normal_uni[2] == -1:
        self.surface_orientation = -2
    elif normal_uni[2] == 1:
        self.surface_orientation = -1
    return self.surface_orientation</code></pre>
</details>
</dd>
<dt id="teaser.data.surfacegml.SurfaceGML.get_gml_tilt"><code class="name flex">
<span>def <span class="ident">get_gml_tilt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>calc the tilt of a gml_surface defined by 4 or 5 gml coordinates</p>
<p>Surface needs to be planar</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>surface_tilt</code></strong> :&ensp;<code>float</code></dt>
<dd>returns the orientation of the surface</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gml_tilt(self):
    &#34;&#34;&#34;calc the tilt of a gml_surface defined by 4 or 5 gml coordinates

    Surface needs to be planar

    Returns
    ----------
    surface_tilt : float
        returns the orientation of the surface
    &#34;&#34;&#34;

    gml_surface = np.array(self.gml_surface)
    gml1 = gml_surface[0:3]
    gml2 = gml_surface[3:6]
    gml3 = gml_surface[6:9]

    vektor_1 = gml2 - gml1
    vektor_2 = gml3 - gml1

    normal_1 = np.cross(vektor_1, vektor_2)
    z_axis = np.array([0, 0, 1])

    self.surface_tilt = np.arccos(np.dot(normal_1, z_axis) / (LA.norm(
        z_axis) * LA.norm(normal_1))) * 360 / (2 * np.pi)

    if self.surface_tilt == 180:
        self.surface_tilt = 0.0
    elif str(self.surface_tilt) == &#34;nan&#34;:
        self.surface_tilt = None
    return self.surface_tilt</code></pre>
</details>
</dd>
<dt id="teaser.data.surfacegml.SurfaceGML.poly_area"><code class="name flex">
<span>def <span class="ident">poly_area</span></span>(<span>self, poly)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates the area of a polygon with arbitrary points</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>poly</code></strong> :&ensp;<code>list</code></dt>
<dd>polygon as a list in srsDimension = 3</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>float</code></dt>
<dd>returns the area of a polygon</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poly_area(self, poly):
    &#34;&#34;&#34;calculates the area of a polygon with arbitrary points

    Parameters
    ----------

    poly : list
        polygon as a list in srsDimension = 3

    Returns
    ----------

    area : float
        returns the area of a polygon
    &#34;&#34;&#34;

    if len(poly) &lt; 3:  # not a plane - no area
        return 0
    total = [0, 0, 0]
    length = len(poly)
    for i in range(length):
        vi1 = poly[i]
        vi2 = poly[(i + 1) % length]
        prod = np.cross(vi1, vi2)
        total[0] += prod[0]
        total[1] += prod[1]
        total[2] += prod[2]
    result = np.dot(total, self.unit_normal(poly[0], poly[1], poly[2]))
    return abs(result / 2)</code></pre>
</details>
</dd>
<dt id="teaser.data.surfacegml.SurfaceGML.unit_normal"><code class="name flex">
<span>def <span class="ident">unit_normal</span></span>(<span>self, a, b, c)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates the unit normal vector of a surface described by 3 points</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>point 1</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>point 2</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>point 3</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>unit_normal</code></strong> :&ensp;<code>list</code></dt>
<dd>unit normal vector as a list</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_normal(self, a, b, c):
    &#34;&#34;&#34;calculates the unit normal vector of a surface described by 3 points

    Parameters
    ----------

    a : float
        point 1
    b : float
        point 2
    c : float
        point 3

    Returns
    ----------

    unit_normal : list
        unit normal vector as a list

    &#34;&#34;&#34;

    x = np.linalg.det([[1, a[1], a[2]],
                       [1, b[1], b[2]],
                       [1, c[1], c[2]]])
    y = np.linalg.det([[a[0], 1, a[2]],
                       [b[0], 1, b[2]],
                       [c[0], 1, c[2]]])
    z = np.linalg.det([[a[0], a[1], 1],
                       [b[0], b[1], 1],
                       [c[0], c[1], 1]])
    magnitude = (x**2 + y**2 + z**2)**.5
    return x / magnitude, y / magnitude, z / magnitude</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="teaser.data" href="index.html">teaser.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="teaser.data.surfacegml.SurfaceGML" href="#teaser.data.surfacegml.SurfaceGML">SurfaceGML</a></code></h4>
<ul class="">
<li><code><a title="teaser.data.surfacegml.SurfaceGML.get_gml_area" href="#teaser.data.surfacegml.SurfaceGML.get_gml_area">get_gml_area</a></code></li>
<li><code><a title="teaser.data.surfacegml.SurfaceGML.get_gml_orientation" href="#teaser.data.surfacegml.SurfaceGML.get_gml_orientation">get_gml_orientation</a></code></li>
<li><code><a title="teaser.data.surfacegml.SurfaceGML.get_gml_tilt" href="#teaser.data.surfacegml.SurfaceGML.get_gml_tilt">get_gml_tilt</a></code></li>
<li><code><a title="teaser.data.surfacegml.SurfaceGML.poly_area" href="#teaser.data.surfacegml.SurfaceGML.poly_area">poly_area</a></code></li>
<li><code><a title="teaser.data.surfacegml.SurfaceGML.unit_normal" href="#teaser.data.surfacegml.SurfaceGML.unit_normal">unit_normal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>