<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>teaser.logic.archetypebuildings.bmvbs.office API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>teaser.logic.archetypebuildings.bmvbs.office</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># created June 2015
# by TEASER4 Development Team


import math
import collections
from teaser.logic.archetypebuildings.nonresidential import NonResidential
from teaser.logic.buildingobjects.useconditions import UseConditions as UseCond
from teaser.logic.buildingobjects.buildingphysics.ceiling import Ceiling
from teaser.logic.buildingobjects.buildingphysics.floor import Floor
from teaser.logic.buildingobjects.buildingphysics.groundfloor import GroundFloor
from teaser.logic.buildingobjects.buildingphysics.innerwall import InnerWall
from teaser.logic.buildingobjects.buildingphysics.outerwall import OuterWall
from teaser.logic.buildingobjects.buildingphysics.rooftop import Rooftop
from teaser.logic.buildingobjects.buildingphysics.window import Window
from teaser.logic.buildingobjects.thermalzone import ThermalZone


class Office(NonResidential):
    &#34;&#34;&#34;Archetype Office Building according to BMVBS

    Subclass from NonResidential archetype class to represent office buildings.

    The office module contains a multi zone building according to BMVBS (see
    :cite:`BundesministeriumfurVerkehrBauundStadtentwicklung.December2010`).
    This German office building contains 6 usage zones (zones with similar
    thermal behaviour). Each zone has 4 outer walls, 4 windows, a roof and a
    ground floor. Depending on zone usage (typical length and width), an
    interior
    wall area is assigned. Exterior wall
    surfaces are estimated based on
    :cite:`BundesministeriumfurVerkehrBauundStadtentwicklung.December2010`.
    Refinements of the archetype follow the approach of :cite:`Kaag.March2008`.
    number_of_floors and height_of_floors are
    mandatory parameters. Additional information can be passed
    to the archetype (e.g. floor layout and window layout).

    All default values are given according to
    :cite:`BundesministeriumfurVerkehrBauundStadtentwicklung.December2010` and
    :cite:`Kaag.March2008` if not stated otherwise.

    In detail the net leased area is divided into the following thermal zone
    areas:

    #. Office (50% of net leased area)
    #. Floor (25% of net leased area)
    #. Storage (15% of net leased area)
    #. Meeting (4% of net leased area)
    #. Restroom (4% of net leased area)
    #. ICT (2% of net leased area)

    Parameters
    ----------

    parent: Project()
        The parent class of this object, the Project the Building belongs to.
        Allows for better control of hierarchical structures. If not None it
        adds this Building instance to Project.buildings.
        (default: None)
    name : str
        Individual name
    year_of_construction : int
        Year of first construction
    height_of_floors : float [m]
        Average height of the buildings&#39; floors
    number_of_floors : int
        Number of building&#39;s floors above ground
    net_leased_area : float [m2]
        Total net leased area of building. This is area is NOT the footprint
        of a building
    with_ahu : Boolean
        If set to True, an empty instance of BuildingAHU is instantiated and
        assigned to attribute central_ahu. This instance holds information for
        central Air Handling units. Default is False.
    internal_gains_mode: int [1, 2, 3]
        mode for the internal gains calculation done in AixLib:
        1: Temperature and activity degree dependent heat flux calculation for persons. The
           calculation is based on  SIA 2024 (default)
        2: Temperature and activity degree independent heat flux calculation for persons, the max.
           heatflowrate is prescribed by the parameter
           fixed_heat_flow_rate_persons.
        3: Temperature and activity degree dependent calculation with
           consideration of moisture and co2. The moisture calculation is
           based on SIA 2024 (2015) and regards persons and non-persons, the co2 calculation is based on
           Engineering ToolBox (2004) and regards only persons.
    office_layout : int
        Structure of the floor plan of office buildings, default is 1,
        which is representative for one elongated floor.
            1: elongated 1 floor
            2: elongated 2 floors
            3: compact (e.g. for a square base building)
    window_layout : int
        Structure of the window facade type, default is 0, which is a generic facade
        representing a statistical mean value of window area. This is the foundation
        for calculating the other window layouts with correction factors.
            0: generic facade
            1: punctuated facade (individual windows)
            2: banner facade (continuous windows)
            3: full glazing
    construction_type : str
        Construction type of used wall constructions default is &#34;heavy&#34;)
            heavy: heavy construction
            light: light construction

    Note
    ----------
    The listed attributes are just the ones that are set by the user
    calculated values are not included in this list. Changing these values is
    expert mode.

    Attributes
    ----------

    zone_area_factors : dict
        This dictionary contains the name of the zone (str), the
        zone area factor (float) and the zone usage from BoundaryConditions json
        (str). (Default see doc string above)
    outer_wall_names : dict
        This dictionary contains a random name for the outer walls,
        their orientation and tilt. Default is a building in north-south
        orientation)
    roof_names : dict
        This dictionary contains the name of the roofs, their orientation
        and tilt. Default is one flat roof.
    ground_floor_names : dict
        This dictionary contains the name of the ground floors, their
        orientation and tilt. Default is one ground floor.
    window_names : dict
        This dictionary contains the name of the window, their
        orientation and tilt. Default is a building in north-south
        orientation)
    inner_wall_names : dict
        This dictionary contains the name of the inner walls, their
        orientation and tilt. Default is one cumulated inner wall.
    ceiling_names : dict
        This dictionary contains the name of the ceilings, their
        orientation and tilt. Default is one cumulated ceiling.
    floor_names : dict
        This dictionary contains the name of the floors, their
        orientation and tilt. Default is one cumulated floor.
    gross_factor : float
        gross factor used to correct the rooftop and floor area (default is
        1.15)
    est_factor_wall_area : float
        estimation factor to calculate outer wall area
    est_exponent_wall : float
        estimation factor exponent to calculate outer wall area
    est_factor_win_area : float
        estimation factor to calculate window area
    est_exponent_win : float
        estimation factor exponent to calculate window area
    &#34;&#34;&#34;

    def __init__(
        self,
        parent,
        name=None,
        year_of_construction=None,
        number_of_floors=None,
        height_of_floors=None,
        net_leased_area=None,
        with_ahu=False,
        internal_gains_mode=1,
        office_layout=None,
        window_layout=None,
        construction_type=None,
    ):
        &#34;&#34;&#34;Constructor of Office archetype
        &#34;&#34;&#34;
        super(Office, self).__init__(
            parent,
            name,
            year_of_construction,
            net_leased_area,
            with_ahu,
            internal_gains_mode,
        )

        self.office_layout = office_layout
        self.window_layout = window_layout
        self.construction_type = construction_type
        self.number_of_floors = number_of_floors
        self.height_of_floors = height_of_floors
        # Parameters are default values for current
        # calculation following Lichtmess

        # [area factor, usage type(has to be set)]
        self.zone_area_factors = collections.OrderedDict()
        self.zone_area_factors[&#34;Office&#34;] = [
            0.5,
            &#34;Group Office (between 2 and 6 employees)&#34;,
        ]
        self.zone_area_factors[&#34;Floor&#34;] = [0.25, &#34;Traffic area&#34;]
        self.zone_area_factors[&#34;Storage&#34;] = [
            0.15,
            &#34;Stock, technical equipment, archives&#34;,
        ]
        self.zone_area_factors[&#34;Meeting&#34;] = [0.04, &#34;Meeting, Conference, seminar&#34;]
        self.zone_area_factors[&#34;Restroom&#34;] = [
            0.04,
            &#34;WC and sanitary rooms in non-residential buildings&#34;,
        ]
        self.zone_area_factors[&#34;ICT&#34;] = [0.02, &#34;Data center&#34;]

        # [tilt, orientation]
        self.outer_wall_names = {
            &#34;Exterior Facade North&#34;: [90, 0],
            &#34;Exterior Facade East&#34;: [90, 90],
            &#34;Exterior Facade South&#34;: [90, 180],
            &#34;Exterior Facade West&#34;: [90, 270],
        }

        self.roof_names = {&#34;Rooftop&#34;: [0, -1]}

        self.ground_floor_names = {&#34;Ground Floor&#34;: [0, -2]}

        self.window_names = {
            &#34;Window Facade North&#34;: [90, 0],
            &#34;Window Facade East&#34;: [90, 90],
            &#34;Window Facade South&#34;: [90, 180],
            &#34;Window Facade West&#34;: [90, 270],
        }

        self.inner_wall_names = {&#34;InnerWall&#34;: [90, 0]}

        self.ceiling_names = {&#34;Ceiling&#34;: [0, -1]}

        self.floor_names = {&#34;Floor&#34;: [0, -2]}

        self.gross_factor = 1.15  # based on :cite:`Liebchen.2007`
        self.est_factor_wall_area = 0.7658
        self.est_exponent_wall = 0.9206
        self.est_factor_win_area = 0.074
        self.est_exponent_win = 1.0889

        # estimated intermediate calculated values
        self._est_outer_wall_area = 0
        self._est_win_area = 0
        self._est_roof_area = 0
        self._est_floor_area = 0
        self._est_facade_area = 0
        self._est_width = 0
        self._est_length = 0

        if self.window_layout == 0:
            self.corr_factor_wall = 1.0
            self.corr_factor_win = 1.0
        elif self.window_layout == 1:
            self.corr_factor_wall = 0.75
            self.corr_factor_win = 0.25
        elif self.window_layout == 2:
            self.corr_factor_wall = 0.5
            self.corr_factor_win = 0.5
        elif self.window_layout == 3:
            self.corr_factor_wall = 0.1
            self.corr_factor_win = 0.9
        else:
            raise ValueError(&#34;window_layout value has to be between 0 - 3&#34;)

        if self.office_layout == 0 or self.office_layout == 1:
            self._est_width = 13.0
        elif self.office_layout == 2:
            self._est_width = 15.0
        elif self.office_layout == 3:
            self._est_width = math.sqrt(
                (self.net_leased_area / self.number_of_floors) * self.gross_factor
            )
        else:
            raise ValueError(&#34;office_layout value has to be between 0 - 3&#34;)
        if self.net_leased_area is not None and self.number_of_floors is not None:
            self._est_length = (
                (self.net_leased_area / self.number_of_floors) * self.gross_factor
            ) / self._est_width
        else:
            pass

        # default values for AHU
        if self.with_ahu is True:
            self.central_ahu.temperature_profile = (
                7 * [293.15] + 12 * [295.15] + 5 * [293.15]
            )
            #  according to :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.min_relative_humidity_profile = 24 * [0.45]  #
            #  according to :cite:`DeutschesInstitutfurNormung.2016b`  and
            # :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.max_relative_humidity_profile = 24 * [0.65]
            self.central_ahu.v_flow_profile = (
                7 * [0.0] + 12 * [1.0] + 5 * [0.0]
            )  # according to user
            # profile in :cite:`DeutschesInstitutfurNormung.2016`

    def generate_archetype(self):
        &#34;&#34;&#34;Generates an office building.

        With given values, this class generates an office archetype building
        according to TEASER requirements.
        &#34;&#34;&#34;
        # help area for the correct building area setting while using typeBldgs
        self.thermal_zones = None
        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0
        # create zones with their corresponding area, name and usage
        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.area = type_bldg_area * value[0]
            zone.name = key
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1], data_class=self.parent.data)
            zone.use_conditions = use_cond

        # statistical estimation of the facade

        self._est_outer_wall_area = (
            self.est_factor_wall_area * type_bldg_area ** self.est_exponent_wall
        )
        self._est_win_area = (
            self.est_factor_win_area * type_bldg_area ** self.est_exponent_win
        )
        self._est_roof_area = (
            type_bldg_area / self.number_of_floors
        ) * self.gross_factor
        self._est_floor_area = (
            type_bldg_area / self.number_of_floors
        ) * self.gross_factor

        # manipulation of wall according to facade design
        # (received from window_layout)

        self._est_facade_area = self._est_outer_wall_area + self._est_win_area

        if not self.window_layout == 0:
            self._est_outer_wall_area = self._est_facade_area * self.corr_factor_wall
            self._est_win_area = self._est_facade_area * self.corr_factor_win
        else:
            pass

        # set the facade area to the four orientations

        for key, value in self.outer_wall_names.items():
            # North and South
            if value[1] == 0 or value[1] == 180:
                self.outer_area[value[1]] = self._est_outer_wall_area * (
                    self._est_length / (2 * self._est_width + 2 * self._est_length)
                )
            # East and West
            elif value[1] == 90 or value[1] == 270:

                self.outer_area[value[1]] = self._est_outer_wall_area * (
                    self._est_width / (2 * self._est_width + 2 * self._est_length)
                )
            for zone in self.thermal_zones:
                # create wall and set building elements
                outer_wall = OuterWall(zone)
                outer_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                outer_wall.name = key
                outer_wall.tilt = value[0]
                outer_wall.orientation = value[1]

        for key, value in self.window_names.items():

            if value[1] == 0 or value[1] == 180:

                self.window_area[value[1]] = self._est_win_area * (
                    self._est_length / (2 * self._est_width + 2 * self._est_length)
                )

            elif value[1] == 90 or value[1] == 270:

                self.window_area[value[1]] = self._est_win_area * (
                    self._est_width / (2 * self._est_width + 2 * self._est_length)
                )

            &#34;&#34;&#34;
            There is no real classification for windows, so this is a bit hard
            code - will be fixed sometime.
            &#34;&#34;&#34;
            for zone in self.thermal_zones:
                window = Window(zone)
                window.load_type_element(
                    self.year_of_construction,
                    &#34;Kunststofffenster, &#34; &#34;Isolierverglasung&#34;,
                    data_class=self.parent.data,
                )
                window.name = key
                window.tilt = value[0]
                window.orientation = value[1]

        for key, value in self.roof_names.items():

            self.outer_area[value[1]] = self._est_roof_area

            for zone in self.thermal_zones:
                roof = Rooftop(zone)
                roof.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                roof.name = key
                roof.tilt = value[0]
                roof.orientation = value[1]

        for key, value in self.ground_floor_names.items():

            self.outer_area[value[1]] = self._est_floor_area

            for zone in self.thermal_zones:
                ground_floor = GroundFloor(zone)
                ground_floor.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                ground_floor.name = key
                ground_floor.tilt = value[0]
                ground_floor.orientation = value[1]

        for key, value in self.inner_wall_names.items():

            for zone in self.thermal_zones:
                inner_wall = InnerWall(zone)
                inner_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                inner_wall.name = key
                inner_wall.tilt = value[0]
                inner_wall.orientation = value[1]

        if self.number_of_floors &gt; 1:

            for key, value in self.ceiling_names.items():

                for zone in self.thermal_zones:
                    ceiling = Ceiling(zone)
                    ceiling.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    ceiling.name = key
                    ceiling.tilt = value[0]
                    ceiling.orientation = value[1]
                    # zone.inner_walls.append(ceiling)

            for key, value in self.floor_names.items():

                for zone in self.thermal_zones:
                    floor = Floor(zone)
                    floor.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    floor.name = key
                    floor.tilt = value[0]
                    floor.orientation = value[1]
        else:
            pass

        for key, value in self.outer_area.items():
            self.set_outer_wall_area(value, key)
        for key, value in self.window_area.items():
            self.set_window_area(value, key)

        for zone in self.thermal_zones:
            zone.set_inner_wall_area()
            zone.set_volume_zone()

    def generate_from_gml(self):
        &#34;&#34;&#34;Enriches lod1 or lod2 data from CityGML

        Adds Zones, BoundaryConditions, Material settings for walls and
        windows to the geometric representation of CityGML

        Enrichment of LoD3 and LoD4 added, parallel to original.
        &#34;&#34;&#34;

        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0
        # my variable: decider for inner_wall calculation method
        lod4_innerwalls = False
        # create zones with their corresponding area, name and usage

        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.area = type_bldg_area * value[0]
            zone.name = key
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1],
                                         data_class=self.parent.data)
            zone.use_conditions = use_cond
            zone.use_conditions.with_ahu = False
            zone.use_conditions.persons *= zone.area * 0.01
            zone.use_conditions.machines *= zone.area * 0.01

            # TODO: fix with or without Windows scenario 2

            for surface in self.gml_surfaces:
                # TODO: Do it nicer, that is just for testing
                # if surface.surface_tilt:
                #     surface.surface_tilt = np.around(surface.surface_tilt, 0)
                # else:
                #     pass
                # if surface.surface_tilt:
                #     surface.surface_orientation = np.around(surface.surface_orientation, 3)
                # else:
                #     pass
                # print(surface.name)
                print(surface.surface_tilt)
                print(surface.surface_orientation)
                if surface.surface_tilt is not None and surface.name is None:
                    if surface.surface_tilt == 90:
                        outer_wall = OuterWall(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation

                        window = Window(zone)
                        window.load_type_element(self.year_of_construction,
                                                 &#34;Kunststofffenster, &#34;
                                                 &#34;Isolierverglasung&#34;,
                                                 data_class=self.parent.data)
                        window.name = &#34;asd&#34; + str(surface.surface_tilt)
                        window.tilt = surface.surface_tilt
                        window.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        # Test for Rooftop area calc
                        outer_wall.area = surface.surface_area * value[0]
                    else:
                        outer_wall = Rooftop(zone)
                        print(zone, outer_wall, surface.surface_area)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        # Test for Rooftop area calc
                        outer_wall.area = surface.surface_area * value[0]
                # If Window / Interior Wall area is provided separately

                else:
                    if surface.surface_tilt == 90.0:
                        # print(surface.name)
                        if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                            print(surface.name)
                            outer_wall = OuterWall(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation
                        elif surface.name == &#34;Window&#34;:
                            window = Window(zone)
                            window.load_type_element(self.year_of_construction,
                                                     &#34;Kunststofffenster, &#34;
                                                     &#34;Isolierverglasung&#34;,
                                                     data_class=self.parent.data)
                            window.name = surface.name + str(surface.surface_orientation)
                            window.area = surface.surface_area
                            window.tilt = surface.surface_tilt
                            window.orientation = surface.surface_orientation
                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            inner_wall = InnerWall(zone)
                            inner_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            inner_wall.name = surface.name + str(surface.surface_orientation) \
                                                           + str(surface.surface_area)
                            inner_wall.tilt = surface.surface_tilt
                            inner_wall.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2 and surface.name != &#34;InnerWall&#34;:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        # Test for Rooftop area calc
                        outer_wall.area = surface.surface_area * value[0]

                    elif surface.surface_tilt == 0 and \
                            surface.surface_orientation == \
                            -2 and surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        floor = Floor(zone)
                        floor.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        floor.name = &#34;floor&#34; + str(surface.surface_orientation) \
                                             + str(surface.surface_area)
                        floor.tilt = surface.surface_tilt
                        floor.orientation = surface.surface_orientation

                    else:
                        if surface.name != &#34;InnerWall&#34;:
                            # print(surface.name)
                            outer_wall = Rooftop(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation
                            # Test for Rooftop area calc
                            outer_wall.area = surface.surface_area * value[0]

                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = &#34;ceiling&#34; + str(surface.surface_orientation) \
                                                     + str(surface.surface_area)
                            ceiling.tilt = surface.surface_tilt
                            ceiling.orientation = surface.surface_orientation


            if lod4_innerwalls is False:

                for key, value in self.inner_wall_names.items():
                    for zone in self.thermal_zones:
                        inner_wall = InnerWall(zone)
                        inner_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        inner_wall.name = key
                        inner_wall.tilt = value[0]
                        inner_wall.orientation = value[1]

                if self.number_of_floors &gt; 1:

                    for key, value in self.ceiling_names.items():
                        for zone in self.thermal_zones:
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = key
                            ceiling.tilt = value[0]
                            ceiling.orientation = value[1]

                    for key, value in self.floor_names.items():
                        for zone in self.thermal_zones:
                            floor = Floor(zone)
                            floor.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            floor.name = key
                            floor.tilt = value[0]
                            floor.orientation = value[1]
                else:
                    pass
            else:
                pass
        for surface in self.gml_surfaces:
            if surface.name is None:                                                       # LoD0-2
                if surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                        and surface.surface_orientation != -1:                             # Walls/Windows
                    self.set_outer_wall_area(surface.surface_area *
                                             (1 - self.est_factor_win_area),
                                             surface.surface_orientation, surface.surface_tilt)
                    self.set_window_area(surface.surface_area*self.est_factor_win_area,
                                         surface.surface_orientation)
                # else:                                                                      # Ground/Floor
                #     self.set_outer_wall_area(surface.surface_area,
                #                              surface.surface_orientation)
            else:                                                                          # LoD3-4
                if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34; and surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                        and surface.surface_orientation != -1:
                    self.set_outer_wall_area(surface.surface_area, surface.surface_orientation, surface.surface_tilt)
                elif surface.name == &#34;Window&#34;:

                    # TODO: fix window area calc in here or in building.py: sum before attribution!?

                    self.set_window_area(surface.surface_area, surface.surface_orientation)
                    # print(surface.surface_area)
                elif surface.name == &#34;InnerWall&#34;:
                    self.set_inner_wall_area_lod4(surface.surface_area, surface.surface_orientation)

        if lod4_innerwalls is False:
            for zone in self.thermal_zones:
                zone.set_inner_wall_area()
                zone.set_volume_zone()
        else:
            for zone in self.thermal_zones:
                zone.set_volume_zone()

    @property
    def office_layout(self):
        return self._office_layout

    @office_layout.setter
    def office_layout(self, value):
        if value is not None:
            self._office_layout = value
        else:
            self._office_layout = 0

    @property
    def window_layout(self):
        return self._window_layout

    @window_layout.setter
    def window_layout(self, value):
        if value is not None:
            self._window_layout = value
        else:
            self._window_layout = 0

    @property
    def construction_type(self):
        return self._construction_type

    @construction_type.setter
    def construction_type(self, value):
        if value is not None:
            if value == &#34;heavy&#34; or value == &#34;light&#34;:
                self._construction_type = value
            else:
                raise ValueError(&#34;Construction_type has to be light or heavy&#34;)
        else:
            self._construction_type = &#34;heavy&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="teaser.logic.archetypebuildings.bmvbs.office.Office"><code class="flex name class">
<span>class <span class="ident">Office</span></span>
<span>(</span><span>parent, name=None, year_of_construction=None, number_of_floors=None, height_of_floors=None, net_leased_area=None, with_ahu=False, internal_gains_mode=1, office_layout=None, window_layout=None, construction_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Archetype Office Building according to BMVBS</p>
<p>Subclass from NonResidential archetype class to represent office buildings.</p>
<p>The office module contains a multi zone building according to BMVBS (see
:cite:<code>BundesministeriumfurVerkehrBauundStadtentwicklung.December2010</code>).
This German office building contains 6 usage zones (zones with similar
thermal behaviour). Each zone has 4 outer walls, 4 windows, a roof and a
ground floor. Depending on zone usage (typical length and width), an
interior
wall area is assigned. Exterior wall
surfaces are estimated based on
:cite:<code>BundesministeriumfurVerkehrBauundStadtentwicklung.December2010</code>.
Refinements of the archetype follow the approach of :cite:<code>Kaag.March2008</code>.
number_of_floors and height_of_floors are
mandatory parameters. Additional information can be passed
to the archetype (e.g. floor layout and window layout).</p>
<p>All default values are given according to
:cite:<code>BundesministeriumfurVerkehrBauundStadtentwicklung.December2010</code> and
:cite:<code>Kaag.March2008</code> if not stated otherwise.</p>
<p>In detail the net leased area is divided into the following thermal zone
areas:</p>
<h1 id="office-50-of-net-leased-area">. Office (50% of net leased area)</h1>
<h1 id="floor-25-of-net-leased-area">. Floor (25% of net leased area)</h1>
<h1 id="storage-15-of-net-leased-area">. Storage (15% of net leased area)</h1>
<h1 id="meeting-4-of-net-leased-area">. Meeting (4% of net leased area)</h1>
<h1 id="restroom-4-of-net-leased-area">. Restroom (4% of net leased area)</h1>
<h1 id="ict-2-of-net-leased-area">. ICT (2% of net leased area)</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>Project()</code></dt>
<dd>The parent class of this object, the Project the Building belongs to.
Allows for better control of hierarchical structures. If not None it
adds this Building instance to Project.buildings.
(default: None)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Individual name</dd>
<dt><strong><code>year_of_construction</code></strong> :&ensp;<code>int</code></dt>
<dd>Year of first construction</dd>
<dt><strong><code>height_of_floors</code></strong> :&ensp;<code>float [m]</code></dt>
<dd>Average height of the buildings' floors</dd>
<dt><strong><code>number_of_floors</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of building's floors above ground</dd>
<dt><strong><code>net_leased_area</code></strong> :&ensp;<code>float [m2]</code></dt>
<dd>Total net leased area of building. This is area is NOT the footprint
of a building</dd>
<dt><strong><code>with_ahu</code></strong> :&ensp;<code>Boolean</code></dt>
<dd>If set to True, an empty instance of BuildingAHU is instantiated and
assigned to attribute central_ahu. This instance holds information for
central Air Handling units. Default is False.</dd>
<dt><strong><code>internal_gains_mode</code></strong> :&ensp;<code>int [1, 2, 3]</code></dt>
<dd>mode for the internal gains calculation done in AixLib:
1: Temperature and activity degree dependent heat flux calculation for persons. The
calculation is based on
SIA 2024 (default)
2: Temperature and activity degree independent heat flux calculation for persons, the max.
heatflowrate is prescribed by the parameter
fixed_heat_flow_rate_persons.
3: Temperature and activity degree dependent calculation with
consideration of moisture and co2. The moisture calculation is
based on SIA 2024 (2015) and regards persons and non-persons, the co2 calculation is based on
Engineering ToolBox (2004) and regards only persons.</dd>
<dt><strong><code>office_layout</code></strong> :&ensp;<code>int</code></dt>
<dd>Structure of the floor plan of office buildings, default is 1,
which is representative for one elongated floor.
1: elongated 1 floor
2: elongated 2 floors
3: compact (e.g. for a square base building)</dd>
<dt><strong><code>window_layout</code></strong> :&ensp;<code>int</code></dt>
<dd>Structure of the window facade type, default is 0, which is a generic facade
representing a statistical mean value of window area. This is the foundation
for calculating the other window layouts with correction factors.
0: generic facade
1: punctuated facade (individual windows)
2: banner facade (continuous windows)
3: full glazing</dd>
<dt><strong><code>construction_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Construction type of used wall constructions default is "heavy")
heavy: heavy construction
light: light construction</dd>
</dl>
<h2 id="note">Note</h2>
<p>The listed attributes are just the ones that are set by the user
calculated values are not included in this list. Changing these values is
expert mode.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>zone_area_factors</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the zone (str), the
zone area factor (float) and the zone usage from BoundaryConditions json
(str). (Default see doc string above)</dd>
<dt><strong><code>outer_wall_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains a random name for the outer walls,
their orientation and tilt. Default is a building in north-south
orientation)</dd>
<dt><strong><code>roof_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the roofs, their orientation
and tilt. Default is one flat roof.</dd>
<dt><strong><code>ground_floor_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the ground floors, their
orientation and tilt. Default is one ground floor.</dd>
<dt><strong><code>window_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the window, their
orientation and tilt. Default is a building in north-south
orientation)</dd>
<dt><strong><code>inner_wall_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the inner walls, their
orientation and tilt. Default is one cumulated inner wall.</dd>
<dt><strong><code>ceiling_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the ceilings, their
orientation and tilt. Default is one cumulated ceiling.</dd>
<dt><strong><code>floor_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the floors, their
orientation and tilt. Default is one cumulated floor.</dd>
<dt><strong><code>gross_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>gross factor used to correct the rooftop and floor area (default is
1.15)</dd>
<dt><strong><code>est_factor_wall_area</code></strong> :&ensp;<code>float</code></dt>
<dd>estimation factor to calculate outer wall area</dd>
<dt><strong><code>est_exponent_wall</code></strong> :&ensp;<code>float</code></dt>
<dd>estimation factor exponent to calculate outer wall area</dd>
<dt><strong><code>est_factor_win_area</code></strong> :&ensp;<code>float</code></dt>
<dd>estimation factor to calculate window area</dd>
<dt><strong><code>est_exponent_win</code></strong> :&ensp;<code>float</code></dt>
<dd>estimation factor exponent to calculate window area</dd>
</dl>
<p>Constructor of Office archetype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Office(NonResidential):
    &#34;&#34;&#34;Archetype Office Building according to BMVBS

    Subclass from NonResidential archetype class to represent office buildings.

    The office module contains a multi zone building according to BMVBS (see
    :cite:`BundesministeriumfurVerkehrBauundStadtentwicklung.December2010`).
    This German office building contains 6 usage zones (zones with similar
    thermal behaviour). Each zone has 4 outer walls, 4 windows, a roof and a
    ground floor. Depending on zone usage (typical length and width), an
    interior
    wall area is assigned. Exterior wall
    surfaces are estimated based on
    :cite:`BundesministeriumfurVerkehrBauundStadtentwicklung.December2010`.
    Refinements of the archetype follow the approach of :cite:`Kaag.March2008`.
    number_of_floors and height_of_floors are
    mandatory parameters. Additional information can be passed
    to the archetype (e.g. floor layout and window layout).

    All default values are given according to
    :cite:`BundesministeriumfurVerkehrBauundStadtentwicklung.December2010` and
    :cite:`Kaag.March2008` if not stated otherwise.

    In detail the net leased area is divided into the following thermal zone
    areas:

    #. Office (50% of net leased area)
    #. Floor (25% of net leased area)
    #. Storage (15% of net leased area)
    #. Meeting (4% of net leased area)
    #. Restroom (4% of net leased area)
    #. ICT (2% of net leased area)

    Parameters
    ----------

    parent: Project()
        The parent class of this object, the Project the Building belongs to.
        Allows for better control of hierarchical structures. If not None it
        adds this Building instance to Project.buildings.
        (default: None)
    name : str
        Individual name
    year_of_construction : int
        Year of first construction
    height_of_floors : float [m]
        Average height of the buildings&#39; floors
    number_of_floors : int
        Number of building&#39;s floors above ground
    net_leased_area : float [m2]
        Total net leased area of building. This is area is NOT the footprint
        of a building
    with_ahu : Boolean
        If set to True, an empty instance of BuildingAHU is instantiated and
        assigned to attribute central_ahu. This instance holds information for
        central Air Handling units. Default is False.
    internal_gains_mode: int [1, 2, 3]
        mode for the internal gains calculation done in AixLib:
        1: Temperature and activity degree dependent heat flux calculation for persons. The
           calculation is based on  SIA 2024 (default)
        2: Temperature and activity degree independent heat flux calculation for persons, the max.
           heatflowrate is prescribed by the parameter
           fixed_heat_flow_rate_persons.
        3: Temperature and activity degree dependent calculation with
           consideration of moisture and co2. The moisture calculation is
           based on SIA 2024 (2015) and regards persons and non-persons, the co2 calculation is based on
           Engineering ToolBox (2004) and regards only persons.
    office_layout : int
        Structure of the floor plan of office buildings, default is 1,
        which is representative for one elongated floor.
            1: elongated 1 floor
            2: elongated 2 floors
            3: compact (e.g. for a square base building)
    window_layout : int
        Structure of the window facade type, default is 0, which is a generic facade
        representing a statistical mean value of window area. This is the foundation
        for calculating the other window layouts with correction factors.
            0: generic facade
            1: punctuated facade (individual windows)
            2: banner facade (continuous windows)
            3: full glazing
    construction_type : str
        Construction type of used wall constructions default is &#34;heavy&#34;)
            heavy: heavy construction
            light: light construction

    Note
    ----------
    The listed attributes are just the ones that are set by the user
    calculated values are not included in this list. Changing these values is
    expert mode.

    Attributes
    ----------

    zone_area_factors : dict
        This dictionary contains the name of the zone (str), the
        zone area factor (float) and the zone usage from BoundaryConditions json
        (str). (Default see doc string above)
    outer_wall_names : dict
        This dictionary contains a random name for the outer walls,
        their orientation and tilt. Default is a building in north-south
        orientation)
    roof_names : dict
        This dictionary contains the name of the roofs, their orientation
        and tilt. Default is one flat roof.
    ground_floor_names : dict
        This dictionary contains the name of the ground floors, their
        orientation and tilt. Default is one ground floor.
    window_names : dict
        This dictionary contains the name of the window, their
        orientation and tilt. Default is a building in north-south
        orientation)
    inner_wall_names : dict
        This dictionary contains the name of the inner walls, their
        orientation and tilt. Default is one cumulated inner wall.
    ceiling_names : dict
        This dictionary contains the name of the ceilings, their
        orientation and tilt. Default is one cumulated ceiling.
    floor_names : dict
        This dictionary contains the name of the floors, their
        orientation and tilt. Default is one cumulated floor.
    gross_factor : float
        gross factor used to correct the rooftop and floor area (default is
        1.15)
    est_factor_wall_area : float
        estimation factor to calculate outer wall area
    est_exponent_wall : float
        estimation factor exponent to calculate outer wall area
    est_factor_win_area : float
        estimation factor to calculate window area
    est_exponent_win : float
        estimation factor exponent to calculate window area
    &#34;&#34;&#34;

    def __init__(
        self,
        parent,
        name=None,
        year_of_construction=None,
        number_of_floors=None,
        height_of_floors=None,
        net_leased_area=None,
        with_ahu=False,
        internal_gains_mode=1,
        office_layout=None,
        window_layout=None,
        construction_type=None,
    ):
        &#34;&#34;&#34;Constructor of Office archetype
        &#34;&#34;&#34;
        super(Office, self).__init__(
            parent,
            name,
            year_of_construction,
            net_leased_area,
            with_ahu,
            internal_gains_mode,
        )

        self.office_layout = office_layout
        self.window_layout = window_layout
        self.construction_type = construction_type
        self.number_of_floors = number_of_floors
        self.height_of_floors = height_of_floors
        # Parameters are default values for current
        # calculation following Lichtmess

        # [area factor, usage type(has to be set)]
        self.zone_area_factors = collections.OrderedDict()
        self.zone_area_factors[&#34;Office&#34;] = [
            0.5,
            &#34;Group Office (between 2 and 6 employees)&#34;,
        ]
        self.zone_area_factors[&#34;Floor&#34;] = [0.25, &#34;Traffic area&#34;]
        self.zone_area_factors[&#34;Storage&#34;] = [
            0.15,
            &#34;Stock, technical equipment, archives&#34;,
        ]
        self.zone_area_factors[&#34;Meeting&#34;] = [0.04, &#34;Meeting, Conference, seminar&#34;]
        self.zone_area_factors[&#34;Restroom&#34;] = [
            0.04,
            &#34;WC and sanitary rooms in non-residential buildings&#34;,
        ]
        self.zone_area_factors[&#34;ICT&#34;] = [0.02, &#34;Data center&#34;]

        # [tilt, orientation]
        self.outer_wall_names = {
            &#34;Exterior Facade North&#34;: [90, 0],
            &#34;Exterior Facade East&#34;: [90, 90],
            &#34;Exterior Facade South&#34;: [90, 180],
            &#34;Exterior Facade West&#34;: [90, 270],
        }

        self.roof_names = {&#34;Rooftop&#34;: [0, -1]}

        self.ground_floor_names = {&#34;Ground Floor&#34;: [0, -2]}

        self.window_names = {
            &#34;Window Facade North&#34;: [90, 0],
            &#34;Window Facade East&#34;: [90, 90],
            &#34;Window Facade South&#34;: [90, 180],
            &#34;Window Facade West&#34;: [90, 270],
        }

        self.inner_wall_names = {&#34;InnerWall&#34;: [90, 0]}

        self.ceiling_names = {&#34;Ceiling&#34;: [0, -1]}

        self.floor_names = {&#34;Floor&#34;: [0, -2]}

        self.gross_factor = 1.15  # based on :cite:`Liebchen.2007`
        self.est_factor_wall_area = 0.7658
        self.est_exponent_wall = 0.9206
        self.est_factor_win_area = 0.074
        self.est_exponent_win = 1.0889

        # estimated intermediate calculated values
        self._est_outer_wall_area = 0
        self._est_win_area = 0
        self._est_roof_area = 0
        self._est_floor_area = 0
        self._est_facade_area = 0
        self._est_width = 0
        self._est_length = 0

        if self.window_layout == 0:
            self.corr_factor_wall = 1.0
            self.corr_factor_win = 1.0
        elif self.window_layout == 1:
            self.corr_factor_wall = 0.75
            self.corr_factor_win = 0.25
        elif self.window_layout == 2:
            self.corr_factor_wall = 0.5
            self.corr_factor_win = 0.5
        elif self.window_layout == 3:
            self.corr_factor_wall = 0.1
            self.corr_factor_win = 0.9
        else:
            raise ValueError(&#34;window_layout value has to be between 0 - 3&#34;)

        if self.office_layout == 0 or self.office_layout == 1:
            self._est_width = 13.0
        elif self.office_layout == 2:
            self._est_width = 15.0
        elif self.office_layout == 3:
            self._est_width = math.sqrt(
                (self.net_leased_area / self.number_of_floors) * self.gross_factor
            )
        else:
            raise ValueError(&#34;office_layout value has to be between 0 - 3&#34;)
        if self.net_leased_area is not None and self.number_of_floors is not None:
            self._est_length = (
                (self.net_leased_area / self.number_of_floors) * self.gross_factor
            ) / self._est_width
        else:
            pass

        # default values for AHU
        if self.with_ahu is True:
            self.central_ahu.temperature_profile = (
                7 * [293.15] + 12 * [295.15] + 5 * [293.15]
            )
            #  according to :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.min_relative_humidity_profile = 24 * [0.45]  #
            #  according to :cite:`DeutschesInstitutfurNormung.2016b`  and
            # :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.max_relative_humidity_profile = 24 * [0.65]
            self.central_ahu.v_flow_profile = (
                7 * [0.0] + 12 * [1.0] + 5 * [0.0]
            )  # according to user
            # profile in :cite:`DeutschesInstitutfurNormung.2016`

    def generate_archetype(self):
        &#34;&#34;&#34;Generates an office building.

        With given values, this class generates an office archetype building
        according to TEASER requirements.
        &#34;&#34;&#34;
        # help area for the correct building area setting while using typeBldgs
        self.thermal_zones = None
        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0
        # create zones with their corresponding area, name and usage
        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.area = type_bldg_area * value[0]
            zone.name = key
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1], data_class=self.parent.data)
            zone.use_conditions = use_cond

        # statistical estimation of the facade

        self._est_outer_wall_area = (
            self.est_factor_wall_area * type_bldg_area ** self.est_exponent_wall
        )
        self._est_win_area = (
            self.est_factor_win_area * type_bldg_area ** self.est_exponent_win
        )
        self._est_roof_area = (
            type_bldg_area / self.number_of_floors
        ) * self.gross_factor
        self._est_floor_area = (
            type_bldg_area / self.number_of_floors
        ) * self.gross_factor

        # manipulation of wall according to facade design
        # (received from window_layout)

        self._est_facade_area = self._est_outer_wall_area + self._est_win_area

        if not self.window_layout == 0:
            self._est_outer_wall_area = self._est_facade_area * self.corr_factor_wall
            self._est_win_area = self._est_facade_area * self.corr_factor_win
        else:
            pass

        # set the facade area to the four orientations

        for key, value in self.outer_wall_names.items():
            # North and South
            if value[1] == 0 or value[1] == 180:
                self.outer_area[value[1]] = self._est_outer_wall_area * (
                    self._est_length / (2 * self._est_width + 2 * self._est_length)
                )
            # East and West
            elif value[1] == 90 or value[1] == 270:

                self.outer_area[value[1]] = self._est_outer_wall_area * (
                    self._est_width / (2 * self._est_width + 2 * self._est_length)
                )
            for zone in self.thermal_zones:
                # create wall and set building elements
                outer_wall = OuterWall(zone)
                outer_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                outer_wall.name = key
                outer_wall.tilt = value[0]
                outer_wall.orientation = value[1]

        for key, value in self.window_names.items():

            if value[1] == 0 or value[1] == 180:

                self.window_area[value[1]] = self._est_win_area * (
                    self._est_length / (2 * self._est_width + 2 * self._est_length)
                )

            elif value[1] == 90 or value[1] == 270:

                self.window_area[value[1]] = self._est_win_area * (
                    self._est_width / (2 * self._est_width + 2 * self._est_length)
                )

            &#34;&#34;&#34;
            There is no real classification for windows, so this is a bit hard
            code - will be fixed sometime.
            &#34;&#34;&#34;
            for zone in self.thermal_zones:
                window = Window(zone)
                window.load_type_element(
                    self.year_of_construction,
                    &#34;Kunststofffenster, &#34; &#34;Isolierverglasung&#34;,
                    data_class=self.parent.data,
                )
                window.name = key
                window.tilt = value[0]
                window.orientation = value[1]

        for key, value in self.roof_names.items():

            self.outer_area[value[1]] = self._est_roof_area

            for zone in self.thermal_zones:
                roof = Rooftop(zone)
                roof.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                roof.name = key
                roof.tilt = value[0]
                roof.orientation = value[1]

        for key, value in self.ground_floor_names.items():

            self.outer_area[value[1]] = self._est_floor_area

            for zone in self.thermal_zones:
                ground_floor = GroundFloor(zone)
                ground_floor.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                ground_floor.name = key
                ground_floor.tilt = value[0]
                ground_floor.orientation = value[1]

        for key, value in self.inner_wall_names.items():

            for zone in self.thermal_zones:
                inner_wall = InnerWall(zone)
                inner_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                inner_wall.name = key
                inner_wall.tilt = value[0]
                inner_wall.orientation = value[1]

        if self.number_of_floors &gt; 1:

            for key, value in self.ceiling_names.items():

                for zone in self.thermal_zones:
                    ceiling = Ceiling(zone)
                    ceiling.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    ceiling.name = key
                    ceiling.tilt = value[0]
                    ceiling.orientation = value[1]
                    # zone.inner_walls.append(ceiling)

            for key, value in self.floor_names.items():

                for zone in self.thermal_zones:
                    floor = Floor(zone)
                    floor.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    floor.name = key
                    floor.tilt = value[0]
                    floor.orientation = value[1]
        else:
            pass

        for key, value in self.outer_area.items():
            self.set_outer_wall_area(value, key)
        for key, value in self.window_area.items():
            self.set_window_area(value, key)

        for zone in self.thermal_zones:
            zone.set_inner_wall_area()
            zone.set_volume_zone()

    def generate_from_gml(self):
        &#34;&#34;&#34;Enriches lod1 or lod2 data from CityGML

        Adds Zones, BoundaryConditions, Material settings for walls and
        windows to the geometric representation of CityGML

        Enrichment of LoD3 and LoD4 added, parallel to original.
        &#34;&#34;&#34;

        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0
        # my variable: decider for inner_wall calculation method
        lod4_innerwalls = False
        # create zones with their corresponding area, name and usage

        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.area = type_bldg_area * value[0]
            zone.name = key
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1],
                                         data_class=self.parent.data)
            zone.use_conditions = use_cond
            zone.use_conditions.with_ahu = False
            zone.use_conditions.persons *= zone.area * 0.01
            zone.use_conditions.machines *= zone.area * 0.01

            # TODO: fix with or without Windows scenario 2

            for surface in self.gml_surfaces:
                # TODO: Do it nicer, that is just for testing
                # if surface.surface_tilt:
                #     surface.surface_tilt = np.around(surface.surface_tilt, 0)
                # else:
                #     pass
                # if surface.surface_tilt:
                #     surface.surface_orientation = np.around(surface.surface_orientation, 3)
                # else:
                #     pass
                # print(surface.name)
                print(surface.surface_tilt)
                print(surface.surface_orientation)
                if surface.surface_tilt is not None and surface.name is None:
                    if surface.surface_tilt == 90:
                        outer_wall = OuterWall(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation

                        window = Window(zone)
                        window.load_type_element(self.year_of_construction,
                                                 &#34;Kunststofffenster, &#34;
                                                 &#34;Isolierverglasung&#34;,
                                                 data_class=self.parent.data)
                        window.name = &#34;asd&#34; + str(surface.surface_tilt)
                        window.tilt = surface.surface_tilt
                        window.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        # Test for Rooftop area calc
                        outer_wall.area = surface.surface_area * value[0]
                    else:
                        outer_wall = Rooftop(zone)
                        print(zone, outer_wall, surface.surface_area)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        # Test for Rooftop area calc
                        outer_wall.area = surface.surface_area * value[0]
                # If Window / Interior Wall area is provided separately

                else:
                    if surface.surface_tilt == 90.0:
                        # print(surface.name)
                        if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                            print(surface.name)
                            outer_wall = OuterWall(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation
                        elif surface.name == &#34;Window&#34;:
                            window = Window(zone)
                            window.load_type_element(self.year_of_construction,
                                                     &#34;Kunststofffenster, &#34;
                                                     &#34;Isolierverglasung&#34;,
                                                     data_class=self.parent.data)
                            window.name = surface.name + str(surface.surface_orientation)
                            window.area = surface.surface_area
                            window.tilt = surface.surface_tilt
                            window.orientation = surface.surface_orientation
                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            inner_wall = InnerWall(zone)
                            inner_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            inner_wall.name = surface.name + str(surface.surface_orientation) \
                                                           + str(surface.surface_area)
                            inner_wall.tilt = surface.surface_tilt
                            inner_wall.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2 and surface.name != &#34;InnerWall&#34;:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        # Test for Rooftop area calc
                        outer_wall.area = surface.surface_area * value[0]

                    elif surface.surface_tilt == 0 and \
                            surface.surface_orientation == \
                            -2 and surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        floor = Floor(zone)
                        floor.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        floor.name = &#34;floor&#34; + str(surface.surface_orientation) \
                                             + str(surface.surface_area)
                        floor.tilt = surface.surface_tilt
                        floor.orientation = surface.surface_orientation

                    else:
                        if surface.name != &#34;InnerWall&#34;:
                            # print(surface.name)
                            outer_wall = Rooftop(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation
                            # Test for Rooftop area calc
                            outer_wall.area = surface.surface_area * value[0]

                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = &#34;ceiling&#34; + str(surface.surface_orientation) \
                                                     + str(surface.surface_area)
                            ceiling.tilt = surface.surface_tilt
                            ceiling.orientation = surface.surface_orientation


            if lod4_innerwalls is False:

                for key, value in self.inner_wall_names.items():
                    for zone in self.thermal_zones:
                        inner_wall = InnerWall(zone)
                        inner_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        inner_wall.name = key
                        inner_wall.tilt = value[0]
                        inner_wall.orientation = value[1]

                if self.number_of_floors &gt; 1:

                    for key, value in self.ceiling_names.items():
                        for zone in self.thermal_zones:
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = key
                            ceiling.tilt = value[0]
                            ceiling.orientation = value[1]

                    for key, value in self.floor_names.items():
                        for zone in self.thermal_zones:
                            floor = Floor(zone)
                            floor.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            floor.name = key
                            floor.tilt = value[0]
                            floor.orientation = value[1]
                else:
                    pass
            else:
                pass
        for surface in self.gml_surfaces:
            if surface.name is None:                                                       # LoD0-2
                if surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                        and surface.surface_orientation != -1:                             # Walls/Windows
                    self.set_outer_wall_area(surface.surface_area *
                                             (1 - self.est_factor_win_area),
                                             surface.surface_orientation, surface.surface_tilt)
                    self.set_window_area(surface.surface_area*self.est_factor_win_area,
                                         surface.surface_orientation)
                # else:                                                                      # Ground/Floor
                #     self.set_outer_wall_area(surface.surface_area,
                #                              surface.surface_orientation)
            else:                                                                          # LoD3-4
                if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34; and surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                        and surface.surface_orientation != -1:
                    self.set_outer_wall_area(surface.surface_area, surface.surface_orientation, surface.surface_tilt)
                elif surface.name == &#34;Window&#34;:

                    # TODO: fix window area calc in here or in building.py: sum before attribution!?

                    self.set_window_area(surface.surface_area, surface.surface_orientation)
                    # print(surface.surface_area)
                elif surface.name == &#34;InnerWall&#34;:
                    self.set_inner_wall_area_lod4(surface.surface_area, surface.surface_orientation)

        if lod4_innerwalls is False:
            for zone in self.thermal_zones:
                zone.set_inner_wall_area()
                zone.set_volume_zone()
        else:
            for zone in self.thermal_zones:
                zone.set_volume_zone()

    @property
    def office_layout(self):
        return self._office_layout

    @office_layout.setter
    def office_layout(self, value):
        if value is not None:
            self._office_layout = value
        else:
            self._office_layout = 0

    @property
    def window_layout(self):
        return self._window_layout

    @window_layout.setter
    def window_layout(self, value):
        if value is not None:
            self._window_layout = value
        else:
            self._window_layout = 0

    @property
    def construction_type(self):
        return self._construction_type

    @construction_type.setter
    def construction_type(self, value):
        if value is not None:
            if value == &#34;heavy&#34; or value == &#34;light&#34;:
                self._construction_type = value
            else:
                raise ValueError(&#34;Construction_type has to be light or heavy&#34;)
        else:
            self._construction_type = &#34;heavy&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential" href="../nonresidential.html#teaser.logic.archetypebuildings.nonresidential.NonResidential">NonResidential</a></li>
<li><a title="teaser.logic.buildingobjects.building.Building" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building">Building</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="teaser.logic.archetypebuildings.bmvbs.custom.institute.Institute" href="custom/institute.html#teaser.logic.archetypebuildings.bmvbs.custom.institute.Institute">Institute</a></li>
<li><a title="teaser.logic.archetypebuildings.bmvbs.custom.institute4.Institute4" href="custom/institute4.html#teaser.logic.archetypebuildings.bmvbs.custom.institute4.Institute4">Institute4</a></li>
<li><a title="teaser.logic.archetypebuildings.bmvbs.custom.institute8.Institute8" href="custom/institute8.html#teaser.logic.archetypebuildings.bmvbs.custom.institute8.Institute8">Institute8</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="teaser.logic.archetypebuildings.bmvbs.office.Office.construction_type"><code class="name">var <span class="ident">construction_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def construction_type(self):
    return self._construction_type</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.office.Office.office_layout"><code class="name">var <span class="ident">office_layout</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def office_layout(self):
    return self._office_layout</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.office.Office.window_layout"><code class="name">var <span class="ident">window_layout</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def window_layout(self):
    return self._window_layout</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="teaser.logic.archetypebuildings.bmvbs.office.Office.generate_archetype"><code class="name flex">
<span>def <span class="ident">generate_archetype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an office building.</p>
<p>With given values, this class generates an office archetype building
according to TEASER requirements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_archetype(self):
    &#34;&#34;&#34;Generates an office building.

    With given values, this class generates an office archetype building
    according to TEASER requirements.
    &#34;&#34;&#34;
    # help area for the correct building area setting while using typeBldgs
    self.thermal_zones = None
    type_bldg_area = self.net_leased_area
    self.net_leased_area = 0.0
    # create zones with their corresponding area, name and usage
    for key, value in self.zone_area_factors.items():
        zone = ThermalZone(self)
        zone.area = type_bldg_area * value[0]
        zone.name = key
        use_cond = UseCond(zone)
        use_cond.load_use_conditions(value[1], data_class=self.parent.data)
        zone.use_conditions = use_cond

    # statistical estimation of the facade

    self._est_outer_wall_area = (
        self.est_factor_wall_area * type_bldg_area ** self.est_exponent_wall
    )
    self._est_win_area = (
        self.est_factor_win_area * type_bldg_area ** self.est_exponent_win
    )
    self._est_roof_area = (
        type_bldg_area / self.number_of_floors
    ) * self.gross_factor
    self._est_floor_area = (
        type_bldg_area / self.number_of_floors
    ) * self.gross_factor

    # manipulation of wall according to facade design
    # (received from window_layout)

    self._est_facade_area = self._est_outer_wall_area + self._est_win_area

    if not self.window_layout == 0:
        self._est_outer_wall_area = self._est_facade_area * self.corr_factor_wall
        self._est_win_area = self._est_facade_area * self.corr_factor_win
    else:
        pass

    # set the facade area to the four orientations

    for key, value in self.outer_wall_names.items():
        # North and South
        if value[1] == 0 or value[1] == 180:
            self.outer_area[value[1]] = self._est_outer_wall_area * (
                self._est_length / (2 * self._est_width + 2 * self._est_length)
            )
        # East and West
        elif value[1] == 90 or value[1] == 270:

            self.outer_area[value[1]] = self._est_outer_wall_area * (
                self._est_width / (2 * self._est_width + 2 * self._est_length)
            )
        for zone in self.thermal_zones:
            # create wall and set building elements
            outer_wall = OuterWall(zone)
            outer_wall.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            outer_wall.name = key
            outer_wall.tilt = value[0]
            outer_wall.orientation = value[1]

    for key, value in self.window_names.items():

        if value[1] == 0 or value[1] == 180:

            self.window_area[value[1]] = self._est_win_area * (
                self._est_length / (2 * self._est_width + 2 * self._est_length)
            )

        elif value[1] == 90 or value[1] == 270:

            self.window_area[value[1]] = self._est_win_area * (
                self._est_width / (2 * self._est_width + 2 * self._est_length)
            )

        &#34;&#34;&#34;
        There is no real classification for windows, so this is a bit hard
        code - will be fixed sometime.
        &#34;&#34;&#34;
        for zone in self.thermal_zones:
            window = Window(zone)
            window.load_type_element(
                self.year_of_construction,
                &#34;Kunststofffenster, &#34; &#34;Isolierverglasung&#34;,
                data_class=self.parent.data,
            )
            window.name = key
            window.tilt = value[0]
            window.orientation = value[1]

    for key, value in self.roof_names.items():

        self.outer_area[value[1]] = self._est_roof_area

        for zone in self.thermal_zones:
            roof = Rooftop(zone)
            roof.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            roof.name = key
            roof.tilt = value[0]
            roof.orientation = value[1]

    for key, value in self.ground_floor_names.items():

        self.outer_area[value[1]] = self._est_floor_area

        for zone in self.thermal_zones:
            ground_floor = GroundFloor(zone)
            ground_floor.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            ground_floor.name = key
            ground_floor.tilt = value[0]
            ground_floor.orientation = value[1]

    for key, value in self.inner_wall_names.items():

        for zone in self.thermal_zones:
            inner_wall = InnerWall(zone)
            inner_wall.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            inner_wall.name = key
            inner_wall.tilt = value[0]
            inner_wall.orientation = value[1]

    if self.number_of_floors &gt; 1:

        for key, value in self.ceiling_names.items():

            for zone in self.thermal_zones:
                ceiling = Ceiling(zone)
                ceiling.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                ceiling.name = key
                ceiling.tilt = value[0]
                ceiling.orientation = value[1]
                # zone.inner_walls.append(ceiling)

        for key, value in self.floor_names.items():

            for zone in self.thermal_zones:
                floor = Floor(zone)
                floor.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                floor.name = key
                floor.tilt = value[0]
                floor.orientation = value[1]
    else:
        pass

    for key, value in self.outer_area.items():
        self.set_outer_wall_area(value, key)
    for key, value in self.window_area.items():
        self.set_window_area(value, key)

    for zone in self.thermal_zones:
        zone.set_inner_wall_area()
        zone.set_volume_zone()</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.office.Office.generate_from_gml"><code class="name flex">
<span>def <span class="ident">generate_from_gml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enriches lod1 or lod2 data from CityGML</p>
<p>Adds Zones, BoundaryConditions, Material settings for walls and
windows to the geometric representation of CityGML</p>
<p>Enrichment of LoD3 and LoD4 added, parallel to original.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_from_gml(self):
    &#34;&#34;&#34;Enriches lod1 or lod2 data from CityGML

    Adds Zones, BoundaryConditions, Material settings for walls and
    windows to the geometric representation of CityGML

    Enrichment of LoD3 and LoD4 added, parallel to original.
    &#34;&#34;&#34;

    type_bldg_area = self.net_leased_area
    self.net_leased_area = 0.0
    # my variable: decider for inner_wall calculation method
    lod4_innerwalls = False
    # create zones with their corresponding area, name and usage

    for key, value in self.zone_area_factors.items():
        zone = ThermalZone(self)
        zone.area = type_bldg_area * value[0]
        zone.name = key
        use_cond = UseCond(zone)
        use_cond.load_use_conditions(value[1],
                                     data_class=self.parent.data)
        zone.use_conditions = use_cond
        zone.use_conditions.with_ahu = False
        zone.use_conditions.persons *= zone.area * 0.01
        zone.use_conditions.machines *= zone.area * 0.01

        # TODO: fix with or without Windows scenario 2

        for surface in self.gml_surfaces:
            # TODO: Do it nicer, that is just for testing
            # if surface.surface_tilt:
            #     surface.surface_tilt = np.around(surface.surface_tilt, 0)
            # else:
            #     pass
            # if surface.surface_tilt:
            #     surface.surface_orientation = np.around(surface.surface_orientation, 3)
            # else:
            #     pass
            # print(surface.name)
            print(surface.surface_tilt)
            print(surface.surface_orientation)
            if surface.surface_tilt is not None and surface.name is None:
                if surface.surface_tilt == 90:
                    outer_wall = OuterWall(zone)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation

                    window = Window(zone)
                    window.load_type_element(self.year_of_construction,
                                             &#34;Kunststofffenster, &#34;
                                             &#34;Isolierverglasung&#34;,
                                             data_class=self.parent.data)
                    window.name = &#34;asd&#34; + str(surface.surface_tilt)
                    window.tilt = surface.surface_tilt
                    window.orientation = surface.surface_orientation

                elif surface.surface_tilt == 0 and \
                    surface.surface_orientation == \
                        -2:
                    outer_wall = GroundFloor(zone)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation
                    # Test for Rooftop area calc
                    outer_wall.area = surface.surface_area * value[0]
                else:
                    outer_wall = Rooftop(zone)
                    print(zone, outer_wall, surface.surface_area)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation
                    # Test for Rooftop area calc
                    outer_wall.area = surface.surface_area * value[0]
            # If Window / Interior Wall area is provided separately

            else:
                if surface.surface_tilt == 90.0:
                    # print(surface.name)
                    if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                        print(surface.name)
                        outer_wall = OuterWall(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                    elif surface.name == &#34;Window&#34;:
                        window = Window(zone)
                        window.load_type_element(self.year_of_construction,
                                                 &#34;Kunststofffenster, &#34;
                                                 &#34;Isolierverglasung&#34;,
                                                 data_class=self.parent.data)
                        window.name = surface.name + str(surface.surface_orientation)
                        window.area = surface.surface_area
                        window.tilt = surface.surface_tilt
                        window.orientation = surface.surface_orientation
                    elif surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        inner_wall = InnerWall(zone)
                        inner_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        inner_wall.name = surface.name + str(surface.surface_orientation) \
                                                       + str(surface.surface_area)
                        inner_wall.tilt = surface.surface_tilt
                        inner_wall.orientation = surface.surface_orientation

                elif surface.surface_tilt == 0 and \
                    surface.surface_orientation == \
                        -2 and surface.name != &#34;InnerWall&#34;:
                    outer_wall = GroundFloor(zone)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation
                    # Test for Rooftop area calc
                    outer_wall.area = surface.surface_area * value[0]

                elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                        -2 and surface.name == &#34;InnerWall&#34;:
                    lod4_innerwalls = True
                    floor = Floor(zone)
                    floor.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    floor.name = &#34;floor&#34; + str(surface.surface_orientation) \
                                         + str(surface.surface_area)
                    floor.tilt = surface.surface_tilt
                    floor.orientation = surface.surface_orientation

                else:
                    if surface.name != &#34;InnerWall&#34;:
                        # print(surface.name)
                        outer_wall = Rooftop(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        # Test for Rooftop area calc
                        outer_wall.area = surface.surface_area * value[0]

                    elif surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        ceiling = Ceiling(zone)
                        ceiling.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        ceiling.name = &#34;ceiling&#34; + str(surface.surface_orientation) \
                                                 + str(surface.surface_area)
                        ceiling.tilt = surface.surface_tilt
                        ceiling.orientation = surface.surface_orientation


        if lod4_innerwalls is False:

            for key, value in self.inner_wall_names.items():
                for zone in self.thermal_zones:
                    inner_wall = InnerWall(zone)
                    inner_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    inner_wall.name = key
                    inner_wall.tilt = value[0]
                    inner_wall.orientation = value[1]

            if self.number_of_floors &gt; 1:

                for key, value in self.ceiling_names.items():
                    for zone in self.thermal_zones:
                        ceiling = Ceiling(zone)
                        ceiling.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        ceiling.name = key
                        ceiling.tilt = value[0]
                        ceiling.orientation = value[1]

                for key, value in self.floor_names.items():
                    for zone in self.thermal_zones:
                        floor = Floor(zone)
                        floor.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        floor.name = key
                        floor.tilt = value[0]
                        floor.orientation = value[1]
            else:
                pass
        else:
            pass
    for surface in self.gml_surfaces:
        if surface.name is None:                                                       # LoD0-2
            if surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                    and surface.surface_orientation != -1:                             # Walls/Windows
                self.set_outer_wall_area(surface.surface_area *
                                         (1 - self.est_factor_win_area),
                                         surface.surface_orientation, surface.surface_tilt)
                self.set_window_area(surface.surface_area*self.est_factor_win_area,
                                     surface.surface_orientation)
            # else:                                                                      # Ground/Floor
            #     self.set_outer_wall_area(surface.surface_area,
            #                              surface.surface_orientation)
        else:                                                                          # LoD3-4
            if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34; and surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                    and surface.surface_orientation != -1:
                self.set_outer_wall_area(surface.surface_area, surface.surface_orientation, surface.surface_tilt)
            elif surface.name == &#34;Window&#34;:

                # TODO: fix window area calc in here or in building.py: sum before attribution!?

                self.set_window_area(surface.surface_area, surface.surface_orientation)
                # print(surface.surface_area)
            elif surface.name == &#34;InnerWall&#34;:
                self.set_inner_wall_area_lod4(surface.surface_area, surface.surface_orientation)

    if lod4_innerwalls is False:
        for zone in self.thermal_zones:
            zone.set_inner_wall_area()
            zone.set_volume_zone()
    else:
        for zone in self.thermal_zones:
            zone.set_volume_zone()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential" href="../nonresidential.html#teaser.logic.archetypebuildings.nonresidential.NonResidential">NonResidential</a></b></code>:
<ul class="hlist">
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.add_lca_data_elec" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_lca_data_elec">add_lca_data_elec</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.add_lca_data_heating" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_lca_data_heating">add_lca_data_heating</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.add_lca_data_template" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_lca_data_template">add_lca_data_template</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.add_zone" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_zone">add_zone</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.calc_building_parameter" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.calc_building_parameter">calc_building_parameter</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.calc_lca_data" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.calc_lca_data">calc_lca_data</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.est_elec_demand" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.est_elec_demand">est_elec_demand</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.fill_outer_area_dict" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.fill_outer_area_dict">fill_outer_area_dict</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.fill_window_area_dict" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.fill_window_area_dict">fill_window_area_dict</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.get_footprint_gml" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_footprint_gml">get_footprint_gml</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.get_inner_wall_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_inner_wall_area">get_inner_wall_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.get_outer_wall_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_outer_wall_area">get_outer_wall_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.get_window_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_window_area">get_window_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.print_be_information" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.print_be_information">print_be_information</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.retrofit_building" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.retrofit_building">retrofit_building</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.rotate_building" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.rotate_building">rotate_building</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.set_gml_attributes" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_gml_attributes">set_gml_attributes</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.set_height_gml" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_height_gml">set_height_gml</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.set_outer_wall_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_outer_wall_area">set_outer_wall_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.nonresidential.NonResidential.set_window_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_window_area">set_window_area</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs" href="index.html">teaser.logic.archetypebuildings.bmvbs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="teaser.logic.archetypebuildings.bmvbs.office.Office" href="#teaser.logic.archetypebuildings.bmvbs.office.Office">Office</a></code></h4>
<ul class="">
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.office.Office.construction_type" href="#teaser.logic.archetypebuildings.bmvbs.office.Office.construction_type">construction_type</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.office.Office.generate_archetype" href="#teaser.logic.archetypebuildings.bmvbs.office.Office.generate_archetype">generate_archetype</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.office.Office.generate_from_gml" href="#teaser.logic.archetypebuildings.bmvbs.office.Office.generate_from_gml">generate_from_gml</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.office.Office.office_layout" href="#teaser.logic.archetypebuildings.bmvbs.office.Office.office_layout">office_layout</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.office.Office.window_layout" href="#teaser.logic.archetypebuildings.bmvbs.office.Office.window_layout">window_layout</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>