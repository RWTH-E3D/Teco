<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># created June 2015
# by TEASER4 Development Team

from teaser.logic.archetypebuildings.residential import Residential
from teaser.logic.buildingobjects.useconditions import UseConditions as UseCond
from teaser.logic.buildingobjects.buildingphysics.ceiling import Ceiling
from teaser.logic.buildingobjects.buildingphysics.floor import Floor
from teaser.logic.buildingobjects.buildingphysics.groundfloor import GroundFloor
from teaser.logic.buildingobjects.buildingphysics.innerwall import InnerWall
from teaser.logic.buildingobjects.buildingphysics.outerwall import OuterWall
from teaser.logic.buildingobjects.buildingphysics.rooftop import Rooftop
from teaser.logic.buildingobjects.buildingphysics.window import Window
from teaser.logic.buildingobjects.thermalzone import ThermalZone


class SingleFamilyDwelling(Residential):
    &#34;&#34;&#34;Archetype Residential Building according

    Subclass from Residential archetype class to represent
    SingleFamilyDwelling according to IWU :cite:`KurzverfahrenIWU`.

    The SingleFamilyDwelling module contains a single zone building. It has 4
    outer walls, 4 windows, a flat roof and a ground floor. Interior wall
    areas are assigned related to typical width and depth of zones according to
    :cite:`SwissSocietyofEngineersandArchitects.March2006`. It makes
    number_of_floors and height_of_floors mandatory parameters.
    Additional information can be passed
    to the archetype (e.g. floor layout and number of neighbors).

    Default values are given according to IWU.

    In detail the net leased area is divided into the following thermal zone
    area:

    #. Single dwelling (100% of net leased area)

    Parameters
    ----------

    parent: Project()
        The parent class of this object, the Project the Building belongs to.
        Allows for better control of hierarchical structures. If not None it
        adds this Building instance to Project.buildings.
        (default: None)
    name : str
        Individual name
    year_of_construction : int
        Year of first construction
    height_of_floors : float [m]
        Average height of the buildings&#39; floors
    number_of_floors : int
        Number of building&#39;s floors above ground
    net_leased_area : float [m2]
        Total net leased area of building. This is area is NOT the footprint
        of a building
    with_ahu : Boolean
        If set to True, an empty instance of BuildingAHU is instantiated and
        assigned to attribute central_ahu. This instance holds information for
        central Air Handling units. Default is False.
    internal_gains_mode: int [1, 2, 3]
        mode for the internal gains calculation done in AixLib:
        1: Temperature and activity degree dependent heat flux calculation. The
           calculation is based on  SIA 2024 (default)
        2: Temperature and activity degree independent heat flux calculation, the max.
           heatflowrate is prescribed by the parameter
           fixed_heat_flow_rate_persons.
        3: Temperature and activity degree dependent calculation with
           consideration of moisture and co2. The moisture calculation is
           based on SIA 2024 (2015), the co2 calculation is based on
           Engineering ToolBox (2004)
    residential_layout : int
        Structure of floor plan (default = 0)
            0: compact
            1: elongated/complex
    neighbour_buildings : int
        Number of neighbour buildings. CAUTION: this will not change
        the orientation of the buildings wall, but just the overall
        exterior wall and window area(!) (default = 0)
            0: no neighbour
            1: one neighbour
            2: two neighbours
    attic : int
        Design of the attic. CAUTION: this will not change the orientation or
        tilt of the roof instances, but just adapt the roof area(!) (default
        = 0)
            0: flat roof
            1: non heated attic
            2: partly heated attic
            3: heated attic
    cellar : int
        Design of the of cellar CAUTION: this will not change the
        orientation, tilt of GroundFloor instances, nor the number or area of
        ThermalZones, but will change GroundFloor area(!) (default = 0)
            0: no cellar
            1: non heated cellar
            2: partly heated cellar
            3: heated cellar
    dormer : str
        Is a dormer attached to the roof? CAUTION: this will not
        change roof or window orientation or tilt, but just adapt the roof
        area(!) (default = 0)
            0: no dormer
            1: dormer
    construction_type : str
        Construction type of used wall constructions default is &#34;heavy&#34;)
            heavy: heavy construction
            light: light construction

    Note
    ----------
    The listed attributes are just the ones that are set by the user
    calculated values are not included in this list. Changing these values is
    expert mode.


    Attributes
    ----------

    zone_area_factors : dict
        This dictionary contains the name of the zone (str), the
        zone area factor (float) and the zone usage from BoundaryConditions json
        (str). (Default see doc string above)
    outer_wall_names : dict
        This dictionary contains a random name for the outer walls,
        their orientation and tilt. Default is a building in north-south
        orientation)
    roof_names : dict
        This dictionary contains the name of the roofs, their orientation
        and tilt. Default is one flat roof.
    ground_floor_names : dict
        This dictionary contains the name of the ground floors, their
        orientation and tilt. Default is one ground floor.
    window_names : dict
        This dictionary contains the name of the window, their
        orientation and tilt. Default is a building in north-south
        orientation)
    inner_wall_names : dict
        This dictionary contains the name of the inner walls, their
        orientation and tilt. Default is one cumulated inner wall.
    ceiling_names : dict
        This dictionary contains the name of the ceilings, their
        orientation and tilt. Default is one cumulated ceiling.
    floor_names : dict
        This dictionary contains the name of the floors, their
        orientation and tilt. Default is one cumulated floor.
    est_living_area_factor : float
        Estimation factor for calculation of number of heated floors
    est_bottom_building_closure : float
        Estimation factor to calculate ground floor area
    est_upper_building_closure : float
        Estimation factor to calculate attic area
    est_factor_win_area : float
        Estimation factor to calculate window area
    est_factor_cellar_area : float
        Estimation factor to calculate heated cellar area
    &#34;&#34;&#34;

    def __init__(
        self,
        parent,
        name=None,
        year_of_construction=None,
        number_of_floors=None,
        height_of_floors=None,
        net_leased_area=None,
        with_ahu=False,
        internal_gains_mode=1,
        residential_layout=None,
        neighbour_buildings=None,
        attic=None,
        cellar=None,
        dormer=None,
        construction_type=None,
    ):
        &#34;&#34;&#34;Constructor of SingleFamilyDwelling
        &#34;&#34;&#34;

        super(SingleFamilyDwelling, self).__init__(
            parent,
            name,
            year_of_construction,
            net_leased_area,
            with_ahu,
            internal_gains_mode,
        )

        self.residential_layout = residential_layout
        self.neighbour_buildings = neighbour_buildings
        self.attic = attic
        self.cellar = cellar
        self.dormer = dormer
        self.construction_type = construction_type
        self.number_of_floors = number_of_floors
        self.height_of_floors = height_of_floors

        # Parameters are default values for current calculation following IWU

        # [area factor, usage type(has to be set)]
        self.zone_area_factors = {&#34;SingleDwelling&#34;: [1, &#34;Living&#34;]}

        self.outer_wall_names = {
            &#34;Exterior Facade North&#34;: [90.0, 0.0],
            &#34;Exterior Facade East&#34;: [90.0, 90.0],
            &#34;Exterior Facade South&#34;: [90.0, 180.0],
            &#34;Exterior Facade West&#34;: [90.0, 270.0],
        }
        # [tilt, orientation]

        self.roof_names = {&#34;Rooftop&#34;: [0, -1]}  # [0, -1]

        self.ground_floor_names = {&#34;Ground Floor&#34;: [0, -2]}  # [0, -2]

        self.window_names = {
            &#34;Window Facade North&#34;: [90.0, 0.0],
            &#34;Window Facade East&#34;: [90.0, 90.0],
            &#34;Window Facade South&#34;: [90.0, 180.0],
            &#34;Window Facade West&#34;: [90.0, 270.0],
        }
        # [tilt, orientation]

        self.inner_wall_names = {&#34;InnerWall&#34;: [90.0, 0.0]}

        self.ceiling_names = {&#34;Ceiling&#34;: [0.0, -1]}

        self.floor_names = {&#34;Floor&#34;: [0.0, -2]}

        self.est_living_area_factor = 0.75  # fW
        self.est_bottom_building_closure = 1.33  # p_FB
        self.est_upper_building_closure = 1.0
        self.est_factor_win_area = 0.2
        self.est_factor_cellar_area = 0.5

        self.nr_of_orientation = len(self.outer_wall_names)

        # estimated intermediate calculated values
        self._living_area_per_floor = 0
        self._number_of_heated_floors = 0
        self._est_factor_heated_cellar = 0
        self._est_factor_heated_attic = 0
        self._est_roof_area = 0
        self._est_ground_floor_area = 0.0
        self._est_win_area = 0
        self._est_outer_wall_area = 0.0
        self._est_cellar_wall_area = 0
        self._est_factor_volume = 0.0

        self.est_factor_neighbour = 0.0  # n_Nachbar
        self.est_extra_floor_area = 0.0  # q_Fa

        if self.neighbour_buildings == 0:
            self._est_factor_neighbour = 0.0
            self._est_extra_floor_area = 50.0
        elif self.neighbour_buildings == 1:
            self._est_factor_neighbour = 1.0
            self._est_extra_floor_area = 30.0
        elif self.neighbour_buildings == 2:
            self._est_factor_neighbour = 2.0
            self._est_extra_floor_area = 10.0

        self._est_facade_to_floor_area = 0.0  # p_Fa

        if self.residential_layout == 0:
            self._est_facade_to_floor_area = 0.66
        elif self.residential_layout == 1:
            self._est_facade_to_floor_area = 0.8

        self._est_factor_heated_attic = 0.0  # f_TB_DG
        self._est_area_per_floor = 0.0  # p_DA
        self._est_area_per_roof = 0.0  # p_OG

        if self.attic == 0:
            self._est_factor_heated_attic = 0.0
            self._est_area_per_floor = 1.33
            self._est_area_per_roof = 0.0
        elif self.attic == 1:
            self._est_factor_heated_attic = 0.0
            self._est_area_per_floor = 0.0
            self._est_area_per_roof = 1.33
        elif self.attic == 2:
            self._est_factor_heated_attic = 0.5
            self._est_area_per_floor = 0.75
            self._est_area_per_roof = 0.67
        elif self.attic == 3:
            self._est_factor_heated_attic = 1.0
            self._est_area_per_floor = 1.5
            self._est_area_per_roof = 0.0

        self._est_factor_heated_cellar = 0.0  # f_TB_KG

        if self.cellar == 0:
            self._est_factor_heated_cellar = 0.0
        elif self.cellar == 1:
            self._est_factor_heated_cellar = 0.0
        elif self.cellar == 2:
            self._est_factor_heated_cellar = 0.5
        elif self.cellar == 3:
            self._est_factor_heated_cellar = 1.0

        self._est_factor_dormer = 0.0

        if self.dormer == 0:
            self._est_factor_dormer = 1.0
        elif self.dormer == 1:
            self._est_factor_dormer = 1.3

        if self.with_ahu is True:
            self.central_ahu.temperature_profile = (
                7 * [293.15] + 12 * [295.15] + 5 * [293.15]
            )
            #  according to :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.min_relative_humidity_profile = 24 * [0.45]
            #  according to :cite:`DeutschesInstitutfurNormung.2016b`  and
            # :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.max_relative_humidity_profile = 24 * [0.65]
            self.central_ahu.v_flow_profile = (
                7 * [0.0] + 12 * [1.0] + 5 * [0.0]
            )  # according to user  #
            # profile in :cite:`DeutschesInstitutfurNormung.2016`

    def generate_archetype(self):
        &#34;&#34;&#34;Generates a SingleFamilyDwelling building.

        With given values, this class generates a archetype building for
        single family dwellings according to TEASER requirements
        &#34;&#34;&#34;
        # help area for the correct building area setting while using typeBldgs
        self.thermal_zones = None
        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0

        self._number_of_heated_floors = (
            self._est_factor_heated_cellar
            + self.number_of_floors
            + self.est_living_area_factor * self._est_factor_heated_attic
        )

        self._living_area_per_floor = type_bldg_area / self._number_of_heated_floors

        self._est_ground_floor_area = (
            self.est_bottom_building_closure * self._living_area_per_floor
        )

        self._est_roof_area = (
            self.est_upper_building_closure
            * self._est_factor_dormer
            * self._est_area_per_floor
            * self._living_area_per_floor
        )

        self._top_floor_area = self._est_area_per_roof * self._living_area_per_floor

        if self._est_roof_area == 0:
            self._est_roof_area = self._top_floor_area

        self._est_facade_area = self._est_facade_to_floor_area * (
            self._living_area_per_floor + self._est_extra_floor_area
        )

        self._est_win_area = self.est_factor_win_area * type_bldg_area

        self._est_cellar_wall_area = (
            self.est_factor_cellar_area
            * self._est_factor_heated_cellar
            * self._est_facade_area
        )

        self._est_outer_wall_area = (
            (self._number_of_heated_floors * self._est_facade_area)
            - self._est_cellar_wall_area
            - self._est_win_area
        )

        # self._est_factor_volume = type_bldg_area * 2.5

        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.name = key
            zone.area = type_bldg_area * value[0]
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1], data_class=self.parent.data)

            zone.use_conditions = use_cond
            zone.use_conditions.with_ahu = False

        for key, value in self.outer_wall_names.items():
            # North and South

            if value[1] == 0 or value[1] == 180.0:
                self.outer_area[value[1]] = (
                    self._est_outer_wall_area / self.nr_of_orientation
                )
            # East and West
            elif value[1] == 90 or value[1] == 270:

                self.outer_area[value[1]] = (
                    self._est_outer_wall_area / self.nr_of_orientation
                )

            for zone in self.thermal_zones:
                # create wall and set building elements
                outer_wall = OuterWall(zone)
                outer_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                outer_wall.name = key
                outer_wall.tilt = value[0]
                outer_wall.orientation = value[1]

        for key, value in self.window_names.items():

            if value[1] == 0 or value[1] == 180:

                self.window_area[value[1]] = self._est_win_area / self.nr_of_orientation

            elif value[1] == 90 or value[1] == 270:

                self.window_area[value[1]] = self._est_win_area / self.nr_of_orientation

            &#34;&#34;&#34;
            There is no real classification for windows, so this is a bit hard
            code - will be fixed sometime
            &#34;&#34;&#34;
            for zone in self.thermal_zones:
                window = Window(zone)

                window.load_type_element(
                    self.year_of_construction,
                    &#34;Kunststofffenster, &#34; &#34;Isolierverglasung&#34;,
                    data_class=self.parent.data,
                )
                window.name = key
                window.tilt = value[0]
                window.orientation = value[1]

        for key, value in self.roof_names.items():

            self.outer_area[value[1]] = self._est_roof_area

            for zone in self.thermal_zones:
                roof = Rooftop(zone)
                roof.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                roof.name = key
                roof.tilt = value[0]
                roof.orientation = value[1]

        for key, value in self.ground_floor_names.items():

            self.outer_area[value[1]] = self._est_ground_floor_area

            for zone in self.thermal_zones:
                ground_floor = GroundFloor(zone)
                ground_floor.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                ground_floor.name = key
                ground_floor.tilt = value[0]
                ground_floor.orientation = value[1]

        for key, value in self.inner_wall_names.items():

            for zone in self.thermal_zones:
                inner_wall = InnerWall(zone)
                inner_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                inner_wall.name = key
                inner_wall.tilt = value[0]
                inner_wall.orientation = value[1]
                # zone.inner_walls.append(inner_wall)

        if self.number_of_floors &gt; 1:

            for key, value in self.ceiling_names.items():

                for zone in self.thermal_zones:
                    ceiling = Ceiling(zone)
                    ceiling.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    ceiling.name = key
                    ceiling.tilt = value[0]
                    ceiling.orientation = value[1]
                    # zone.inner_walls.append(ceiling)

            for key, value in self.floor_names.items():

                for zone in self.thermal_zones:
                    floor = Floor(zone)
                    floor.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    floor.name = key
                    floor.tilt = value[0]
                    floor.orientation = value[1]
                    # zone.inner_walls.append(floor)
        else:
            pass

        for key, value in self.outer_area.items():
            self.set_outer_wall_area(value, key)
        for key, value in self.window_area.items():
            self.set_window_area(value, key)

        for zone in self.thermal_zones:
            zone.set_inner_wall_area()
            zone.set_volume_zone()

    def generate_from_gml(self):
        &#34;&#34;&#34;Enriches lod1 or lod2 data from CityGML

        Adds Zones, BoundaryConditions, Material settings for walls and
        windows to the geometric representation of CityGML

        Enrichment of LoD3 and LoD4 added, parallel to original.
        &#34;&#34;&#34;

        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0
        # my variable: decider for inner_wall calculation method
        lod4_innerwalls = False
        # create zones with their corresponding area, name and usage

        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.area = type_bldg_area * value[0]
            zone.name = key
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1],
                                         data_class=self.parent.data)
            zone.use_conditions = use_cond
            zone.use_conditions.with_ahu = False
            # zone.use_conditions.persons *= zone.area * 0.01
            # zone.use_conditions.machines *= zone.area * 0.01

            # TODO: fix with or without Windows scenario 2

            for surface in self.gml_surfaces:
                if surface.surface_tilt is not None and surface.name is None:
                    if surface.surface_tilt == 90:
                        outer_wall = OuterWall(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        window = Window(zone)
                        window.load_type_element(self.year_of_construction,
                                                 &#34;Kunststofffenster, &#34;
                                                 &#34;Isolierverglasung&#34;,
                                                 data_class=self.parent.data)
                        window.name = &#34;window&#34; + str(surface.surface_tilt)
                        window.tilt = surface.surface_tilt
                        window.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                    else:
                        outer_wall = Rooftop(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                # If Window / Interior Wall area is provided separately

                else:
                    if surface.surface_tilt == 90:
                        if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                            outer_wall = OuterWall(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation
                        elif surface.name == &#34;Window&#34;:
                            window = Window(zone)
                            window.load_type_element(self.year_of_construction,
                                                     &#34;Kunststofffenster, &#34;
                                                     &#34;Isolierverglasung&#34;,
                                                     data_class=self.parent.data)
                            window.name = surface.name + str(surface.surface_orientation)
                            window.area = surface.surface_area
                            window.tilt = surface.surface_tilt
                            window.orientation = surface.surface_orientation
                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            inner_wall = InnerWall(zone)
                            inner_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            inner_wall.name = surface.name + str(surface.surface_orientation) \
                                                           + str(surface.surface_area)
                            inner_wall.tilt = surface.surface_tilt
                            inner_wall.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2 and surface.name != &#34;InnerWall&#34;:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                            surface.surface_orientation == \
                            -2 and surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        floor = Floor(zone)
                        floor.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        floor.name = &#34;floor&#34; + str(surface.surface_orientation) \
                                             + str(surface.surface_area)
                        floor.tilt = surface.surface_tilt
                        floor.orientation = surface.surface_orientation

                    else:
                        if surface.name != &#34;InnerWall&#34;:
                            outer_wall = Rooftop(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation

                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = &#34;ceiling&#34; + str(surface.surface_orientation) \
                                                     + str(surface.surface_area)
                            ceiling.tilt = surface.surface_tilt
                            ceiling.orientation = surface.surface_orientation


            if lod4_innerwalls is False:

                for key, value in self.inner_wall_names.items():
                    for zone in self.thermal_zones:
                        inner_wall = InnerWall(zone)
                        inner_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        inner_wall.name = key
                        inner_wall.tilt = value[0]
                        inner_wall.orientation = value[1]

                if self.number_of_floors &gt; 1:

                    for key, value in self.ceiling_names.items():
                        for zone in self.thermal_zones:
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = key
                            ceiling.tilt = value[0]
                            ceiling.orientation = value[1]

                    for key, value in self.floor_names.items():
                        for zone in self.thermal_zones:
                            floor = Floor(zone)
                            floor.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            floor.name = key
                            floor.tilt = value[0]
                            floor.orientation = value[1]
                else:
                    pass
            else:
                pass

        for surface in self.gml_surfaces:
            if surface.name is None:                                                       # LoD0-2
                if surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                        and surface.surface_orientation != -1:                              # Walls/Windows
                    # self.set_outer_wall_area(surface.surface_area *
                    #                          (1 - self.est_factor_win_area),
                    #                          surface.surface_orientation)
                    self.set_outer_wall_area(surface.surface_area,
                                             surface.surface_orientation, surface.surface_tilt)
                    self.set_window_area(surface.surface_area*self.est_factor_win_area,
                                         surface.surface_orientation)
                    # self.set_window_area(surface.surface_area,
                    #                      surface.surface_orientation)
                else:                                                                      # Ground/Floor
                    self.set_outer_wall_area(surface.surface_area,
                                             surface.surface_orientation, surface.surface_tilt)
            else:                                                                          # LoD3-4
                if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                    self.set_outer_wall_area(surface.surface_area, surface.surface_orientation, surface.surface_tilt)
                elif surface.name == &#34;Window&#34;:

                    # TODO: fix window area calc in here or in building.py: sum before attribution!?

                    self.set_window_area(surface.surface_area, surface.surface_orientation)
                elif surface.name == &#34;InnerWall&#34;:
                    self.set_inner_wall_area_lod4(surface.surface_area, surface.surface_orientation)

        if lod4_innerwalls is False:
            for zone in self.thermal_zones:
                zone.set_inner_wall_area()
                zone.set_volume_zone()
        else:
            for zone in self.thermal_zones:
                zone.set_volume_zone()

    @property
    def residential_layout(self):
        return self._residential_layout

    @residential_layout.setter
    def residential_layout(self, value):
        if value is not None:
            self._residential_layout = value
        else:
            self._residential_layout = 0

    @property
    def neighbour_buildings(self):
        return self._neighbour_buildings

    @neighbour_buildings.setter
    def neighbour_buildings(self, value):
        if value is not None:
            self._neighbour_buildings = value
        else:
            self._neighbour_buildings = 0

    @property
    def attic(self):
        return self._attic

    @attic.setter
    def attic(self, value):
        if value is not None:
            self._attic = value
        else:
            self._attic = 0

    @property
    def cellar(self):
        return self._cellar

    @cellar.setter
    def cellar(self, value):
        if value is not None:
            self._cellar = value
        else:
            self._cellar = 0

    @property
    def dormer(self):
        return self._dormer

    @dormer.setter
    def dormer(self, value):
        if value is not None:
            self._dormer = value
        else:
            self._dormer = 0

    @property
    def construction_type(self):
        return self._construction_type

    @construction_type.setter
    def construction_type(self, value):
        if value is not None:
            if value == &#34;heavy&#34; or value == &#34;light&#34;:
                self._construction_type = value
            else:
                raise ValueError(&#34;Construction_type has to be light or heavy&#34;)
        else:
            self._construction_type = &#34;heavy&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling"><code class="flex name class">
<span>class <span class="ident">SingleFamilyDwelling</span></span>
<span>(</span><span>parent, name=None, year_of_construction=None, number_of_floors=None, height_of_floors=None, net_leased_area=None, with_ahu=False, internal_gains_mode=1, residential_layout=None, neighbour_buildings=None, attic=None, cellar=None, dormer=None, construction_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Archetype Residential Building according</p>
<p>Subclass from Residential archetype class to represent
SingleFamilyDwelling according to IWU :cite:<code>KurzverfahrenIWU</code>.</p>
<p>The SingleFamilyDwelling module contains a single zone building. It has 4
outer walls, 4 windows, a flat roof and a ground floor. Interior wall
areas are assigned related to typical width and depth of zones according to
:cite:<code>SwissSocietyofEngineersandArchitects.March2006</code>. It makes
number_of_floors and height_of_floors mandatory parameters.
Additional information can be passed
to the archetype (e.g. floor layout and number of neighbors).</p>
<p>Default values are given according to IWU.</p>
<p>In detail the net leased area is divided into the following thermal zone
area:</p>
<h1 id="single-dwelling-100-of-net-leased-area">. Single dwelling (100% of net leased area)</h1>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>Project()</code></dt>
<dd>The parent class of this object, the Project the Building belongs to.
Allows for better control of hierarchical structures. If not None it
adds this Building instance to Project.buildings.
(default: None)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Individual name</dd>
<dt><strong><code>year_of_construction</code></strong> :&ensp;<code>int</code></dt>
<dd>Year of first construction</dd>
<dt><strong><code>height_of_floors</code></strong> :&ensp;<code>float [m]</code></dt>
<dd>Average height of the buildings' floors</dd>
<dt><strong><code>number_of_floors</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of building's floors above ground</dd>
<dt><strong><code>net_leased_area</code></strong> :&ensp;<code>float [m2]</code></dt>
<dd>Total net leased area of building. This is area is NOT the footprint
of a building</dd>
<dt><strong><code>with_ahu</code></strong> :&ensp;<code>Boolean</code></dt>
<dd>If set to True, an empty instance of BuildingAHU is instantiated and
assigned to attribute central_ahu. This instance holds information for
central Air Handling units. Default is False.</dd>
<dt><strong><code>internal_gains_mode</code></strong> :&ensp;<code>int [1, 2, 3]</code></dt>
<dd>mode for the internal gains calculation done in AixLib:
1: Temperature and activity degree dependent heat flux calculation. The
calculation is based on
SIA 2024 (default)
2: Temperature and activity degree independent heat flux calculation, the max.
heatflowrate is prescribed by the parameter
fixed_heat_flow_rate_persons.
3: Temperature and activity degree dependent calculation with
consideration of moisture and co2. The moisture calculation is
based on SIA 2024 (2015), the co2 calculation is based on
Engineering ToolBox (2004)</dd>
<dt><strong><code>residential_layout</code></strong> :&ensp;<code>int</code></dt>
<dd>Structure of floor plan (default = 0)
0: compact
1: elongated/complex</dd>
<dt><strong><code>neighbour_buildings</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of neighbour buildings. CAUTION: this will not change
the orientation of the buildings wall, but just the overall
exterior wall and window area(!) (default = 0)
0: no neighbour
1: one neighbour
2: two neighbours</dd>
<dt><strong><code>attic</code></strong> :&ensp;<code>int</code></dt>
<dd>Design of the attic. CAUTION: this will not change the orientation or
tilt of the roof instances, but just adapt the roof area(!) (default
= 0)
0: flat roof
1: non heated attic
2: partly heated attic
3: heated attic</dd>
<dt><strong><code>cellar</code></strong> :&ensp;<code>int</code></dt>
<dd>Design of the of cellar CAUTION: this will not change the
orientation, tilt of GroundFloor instances, nor the number or area of
ThermalZones, but will change GroundFloor area(!) (default = 0)
0: no cellar
1: non heated cellar
2: partly heated cellar
3: heated cellar</dd>
<dt><strong><code>dormer</code></strong> :&ensp;<code>str</code></dt>
<dd>Is a dormer attached to the roof? CAUTION: this will not
change roof or window orientation or tilt, but just adapt the roof
area(!) (default = 0)
0: no dormer
1: dormer</dd>
<dt><strong><code>construction_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Construction type of used wall constructions default is "heavy")
heavy: heavy construction
light: light construction</dd>
</dl>
<h2 id="note">Note</h2>
<p>The listed attributes are just the ones that are set by the user
calculated values are not included in this list. Changing these values is
expert mode.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>zone_area_factors</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the zone (str), the
zone area factor (float) and the zone usage from BoundaryConditions json
(str). (Default see doc string above)</dd>
<dt><strong><code>outer_wall_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains a random name for the outer walls,
their orientation and tilt. Default is a building in north-south
orientation)</dd>
<dt><strong><code>roof_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the roofs, their orientation
and tilt. Default is one flat roof.</dd>
<dt><strong><code>ground_floor_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the ground floors, their
orientation and tilt. Default is one ground floor.</dd>
<dt><strong><code>window_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the window, their
orientation and tilt. Default is a building in north-south
orientation)</dd>
<dt><strong><code>inner_wall_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the inner walls, their
orientation and tilt. Default is one cumulated inner wall.</dd>
<dt><strong><code>ceiling_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the ceilings, their
orientation and tilt. Default is one cumulated ceiling.</dd>
<dt><strong><code>floor_names</code></strong> :&ensp;<code>dict</code></dt>
<dd>This dictionary contains the name of the floors, their
orientation and tilt. Default is one cumulated floor.</dd>
<dt><strong><code>est_living_area_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimation factor for calculation of number of heated floors</dd>
<dt><strong><code>est_bottom_building_closure</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimation factor to calculate ground floor area</dd>
<dt><strong><code>est_upper_building_closure</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimation factor to calculate attic area</dd>
<dt><strong><code>est_factor_win_area</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimation factor to calculate window area</dd>
<dt><strong><code>est_factor_cellar_area</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimation factor to calculate heated cellar area</dd>
</dl>
<p>Constructor of SingleFamilyDwelling</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleFamilyDwelling(Residential):
    &#34;&#34;&#34;Archetype Residential Building according

    Subclass from Residential archetype class to represent
    SingleFamilyDwelling according to IWU :cite:`KurzverfahrenIWU`.

    The SingleFamilyDwelling module contains a single zone building. It has 4
    outer walls, 4 windows, a flat roof and a ground floor. Interior wall
    areas are assigned related to typical width and depth of zones according to
    :cite:`SwissSocietyofEngineersandArchitects.March2006`. It makes
    number_of_floors and height_of_floors mandatory parameters.
    Additional information can be passed
    to the archetype (e.g. floor layout and number of neighbors).

    Default values are given according to IWU.

    In detail the net leased area is divided into the following thermal zone
    area:

    #. Single dwelling (100% of net leased area)

    Parameters
    ----------

    parent: Project()
        The parent class of this object, the Project the Building belongs to.
        Allows for better control of hierarchical structures. If not None it
        adds this Building instance to Project.buildings.
        (default: None)
    name : str
        Individual name
    year_of_construction : int
        Year of first construction
    height_of_floors : float [m]
        Average height of the buildings&#39; floors
    number_of_floors : int
        Number of building&#39;s floors above ground
    net_leased_area : float [m2]
        Total net leased area of building. This is area is NOT the footprint
        of a building
    with_ahu : Boolean
        If set to True, an empty instance of BuildingAHU is instantiated and
        assigned to attribute central_ahu. This instance holds information for
        central Air Handling units. Default is False.
    internal_gains_mode: int [1, 2, 3]
        mode for the internal gains calculation done in AixLib:
        1: Temperature and activity degree dependent heat flux calculation. The
           calculation is based on  SIA 2024 (default)
        2: Temperature and activity degree independent heat flux calculation, the max.
           heatflowrate is prescribed by the parameter
           fixed_heat_flow_rate_persons.
        3: Temperature and activity degree dependent calculation with
           consideration of moisture and co2. The moisture calculation is
           based on SIA 2024 (2015), the co2 calculation is based on
           Engineering ToolBox (2004)
    residential_layout : int
        Structure of floor plan (default = 0)
            0: compact
            1: elongated/complex
    neighbour_buildings : int
        Number of neighbour buildings. CAUTION: this will not change
        the orientation of the buildings wall, but just the overall
        exterior wall and window area(!) (default = 0)
            0: no neighbour
            1: one neighbour
            2: two neighbours
    attic : int
        Design of the attic. CAUTION: this will not change the orientation or
        tilt of the roof instances, but just adapt the roof area(!) (default
        = 0)
            0: flat roof
            1: non heated attic
            2: partly heated attic
            3: heated attic
    cellar : int
        Design of the of cellar CAUTION: this will not change the
        orientation, tilt of GroundFloor instances, nor the number or area of
        ThermalZones, but will change GroundFloor area(!) (default = 0)
            0: no cellar
            1: non heated cellar
            2: partly heated cellar
            3: heated cellar
    dormer : str
        Is a dormer attached to the roof? CAUTION: this will not
        change roof or window orientation or tilt, but just adapt the roof
        area(!) (default = 0)
            0: no dormer
            1: dormer
    construction_type : str
        Construction type of used wall constructions default is &#34;heavy&#34;)
            heavy: heavy construction
            light: light construction

    Note
    ----------
    The listed attributes are just the ones that are set by the user
    calculated values are not included in this list. Changing these values is
    expert mode.


    Attributes
    ----------

    zone_area_factors : dict
        This dictionary contains the name of the zone (str), the
        zone area factor (float) and the zone usage from BoundaryConditions json
        (str). (Default see doc string above)
    outer_wall_names : dict
        This dictionary contains a random name for the outer walls,
        their orientation and tilt. Default is a building in north-south
        orientation)
    roof_names : dict
        This dictionary contains the name of the roofs, their orientation
        and tilt. Default is one flat roof.
    ground_floor_names : dict
        This dictionary contains the name of the ground floors, their
        orientation and tilt. Default is one ground floor.
    window_names : dict
        This dictionary contains the name of the window, their
        orientation and tilt. Default is a building in north-south
        orientation)
    inner_wall_names : dict
        This dictionary contains the name of the inner walls, their
        orientation and tilt. Default is one cumulated inner wall.
    ceiling_names : dict
        This dictionary contains the name of the ceilings, their
        orientation and tilt. Default is one cumulated ceiling.
    floor_names : dict
        This dictionary contains the name of the floors, their
        orientation and tilt. Default is one cumulated floor.
    est_living_area_factor : float
        Estimation factor for calculation of number of heated floors
    est_bottom_building_closure : float
        Estimation factor to calculate ground floor area
    est_upper_building_closure : float
        Estimation factor to calculate attic area
    est_factor_win_area : float
        Estimation factor to calculate window area
    est_factor_cellar_area : float
        Estimation factor to calculate heated cellar area
    &#34;&#34;&#34;

    def __init__(
        self,
        parent,
        name=None,
        year_of_construction=None,
        number_of_floors=None,
        height_of_floors=None,
        net_leased_area=None,
        with_ahu=False,
        internal_gains_mode=1,
        residential_layout=None,
        neighbour_buildings=None,
        attic=None,
        cellar=None,
        dormer=None,
        construction_type=None,
    ):
        &#34;&#34;&#34;Constructor of SingleFamilyDwelling
        &#34;&#34;&#34;

        super(SingleFamilyDwelling, self).__init__(
            parent,
            name,
            year_of_construction,
            net_leased_area,
            with_ahu,
            internal_gains_mode,
        )

        self.residential_layout = residential_layout
        self.neighbour_buildings = neighbour_buildings
        self.attic = attic
        self.cellar = cellar
        self.dormer = dormer
        self.construction_type = construction_type
        self.number_of_floors = number_of_floors
        self.height_of_floors = height_of_floors

        # Parameters are default values for current calculation following IWU

        # [area factor, usage type(has to be set)]
        self.zone_area_factors = {&#34;SingleDwelling&#34;: [1, &#34;Living&#34;]}

        self.outer_wall_names = {
            &#34;Exterior Facade North&#34;: [90.0, 0.0],
            &#34;Exterior Facade East&#34;: [90.0, 90.0],
            &#34;Exterior Facade South&#34;: [90.0, 180.0],
            &#34;Exterior Facade West&#34;: [90.0, 270.0],
        }
        # [tilt, orientation]

        self.roof_names = {&#34;Rooftop&#34;: [0, -1]}  # [0, -1]

        self.ground_floor_names = {&#34;Ground Floor&#34;: [0, -2]}  # [0, -2]

        self.window_names = {
            &#34;Window Facade North&#34;: [90.0, 0.0],
            &#34;Window Facade East&#34;: [90.0, 90.0],
            &#34;Window Facade South&#34;: [90.0, 180.0],
            &#34;Window Facade West&#34;: [90.0, 270.0],
        }
        # [tilt, orientation]

        self.inner_wall_names = {&#34;InnerWall&#34;: [90.0, 0.0]}

        self.ceiling_names = {&#34;Ceiling&#34;: [0.0, -1]}

        self.floor_names = {&#34;Floor&#34;: [0.0, -2]}

        self.est_living_area_factor = 0.75  # fW
        self.est_bottom_building_closure = 1.33  # p_FB
        self.est_upper_building_closure = 1.0
        self.est_factor_win_area = 0.2
        self.est_factor_cellar_area = 0.5

        self.nr_of_orientation = len(self.outer_wall_names)

        # estimated intermediate calculated values
        self._living_area_per_floor = 0
        self._number_of_heated_floors = 0
        self._est_factor_heated_cellar = 0
        self._est_factor_heated_attic = 0
        self._est_roof_area = 0
        self._est_ground_floor_area = 0.0
        self._est_win_area = 0
        self._est_outer_wall_area = 0.0
        self._est_cellar_wall_area = 0
        self._est_factor_volume = 0.0

        self.est_factor_neighbour = 0.0  # n_Nachbar
        self.est_extra_floor_area = 0.0  # q_Fa

        if self.neighbour_buildings == 0:
            self._est_factor_neighbour = 0.0
            self._est_extra_floor_area = 50.0
        elif self.neighbour_buildings == 1:
            self._est_factor_neighbour = 1.0
            self._est_extra_floor_area = 30.0
        elif self.neighbour_buildings == 2:
            self._est_factor_neighbour = 2.0
            self._est_extra_floor_area = 10.0

        self._est_facade_to_floor_area = 0.0  # p_Fa

        if self.residential_layout == 0:
            self._est_facade_to_floor_area = 0.66
        elif self.residential_layout == 1:
            self._est_facade_to_floor_area = 0.8

        self._est_factor_heated_attic = 0.0  # f_TB_DG
        self._est_area_per_floor = 0.0  # p_DA
        self._est_area_per_roof = 0.0  # p_OG

        if self.attic == 0:
            self._est_factor_heated_attic = 0.0
            self._est_area_per_floor = 1.33
            self._est_area_per_roof = 0.0
        elif self.attic == 1:
            self._est_factor_heated_attic = 0.0
            self._est_area_per_floor = 0.0
            self._est_area_per_roof = 1.33
        elif self.attic == 2:
            self._est_factor_heated_attic = 0.5
            self._est_area_per_floor = 0.75
            self._est_area_per_roof = 0.67
        elif self.attic == 3:
            self._est_factor_heated_attic = 1.0
            self._est_area_per_floor = 1.5
            self._est_area_per_roof = 0.0

        self._est_factor_heated_cellar = 0.0  # f_TB_KG

        if self.cellar == 0:
            self._est_factor_heated_cellar = 0.0
        elif self.cellar == 1:
            self._est_factor_heated_cellar = 0.0
        elif self.cellar == 2:
            self._est_factor_heated_cellar = 0.5
        elif self.cellar == 3:
            self._est_factor_heated_cellar = 1.0

        self._est_factor_dormer = 0.0

        if self.dormer == 0:
            self._est_factor_dormer = 1.0
        elif self.dormer == 1:
            self._est_factor_dormer = 1.3

        if self.with_ahu is True:
            self.central_ahu.temperature_profile = (
                7 * [293.15] + 12 * [295.15] + 5 * [293.15]
            )
            #  according to :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.min_relative_humidity_profile = 24 * [0.45]
            #  according to :cite:`DeutschesInstitutfurNormung.2016b`  and
            # :cite:`DeutschesInstitutfurNormung.2016`
            self.central_ahu.max_relative_humidity_profile = 24 * [0.65]
            self.central_ahu.v_flow_profile = (
                7 * [0.0] + 12 * [1.0] + 5 * [0.0]
            )  # according to user  #
            # profile in :cite:`DeutschesInstitutfurNormung.2016`

    def generate_archetype(self):
        &#34;&#34;&#34;Generates a SingleFamilyDwelling building.

        With given values, this class generates a archetype building for
        single family dwellings according to TEASER requirements
        &#34;&#34;&#34;
        # help area for the correct building area setting while using typeBldgs
        self.thermal_zones = None
        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0

        self._number_of_heated_floors = (
            self._est_factor_heated_cellar
            + self.number_of_floors
            + self.est_living_area_factor * self._est_factor_heated_attic
        )

        self._living_area_per_floor = type_bldg_area / self._number_of_heated_floors

        self._est_ground_floor_area = (
            self.est_bottom_building_closure * self._living_area_per_floor
        )

        self._est_roof_area = (
            self.est_upper_building_closure
            * self._est_factor_dormer
            * self._est_area_per_floor
            * self._living_area_per_floor
        )

        self._top_floor_area = self._est_area_per_roof * self._living_area_per_floor

        if self._est_roof_area == 0:
            self._est_roof_area = self._top_floor_area

        self._est_facade_area = self._est_facade_to_floor_area * (
            self._living_area_per_floor + self._est_extra_floor_area
        )

        self._est_win_area = self.est_factor_win_area * type_bldg_area

        self._est_cellar_wall_area = (
            self.est_factor_cellar_area
            * self._est_factor_heated_cellar
            * self._est_facade_area
        )

        self._est_outer_wall_area = (
            (self._number_of_heated_floors * self._est_facade_area)
            - self._est_cellar_wall_area
            - self._est_win_area
        )

        # self._est_factor_volume = type_bldg_area * 2.5

        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.name = key
            zone.area = type_bldg_area * value[0]
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1], data_class=self.parent.data)

            zone.use_conditions = use_cond
            zone.use_conditions.with_ahu = False

        for key, value in self.outer_wall_names.items():
            # North and South

            if value[1] == 0 or value[1] == 180.0:
                self.outer_area[value[1]] = (
                    self._est_outer_wall_area / self.nr_of_orientation
                )
            # East and West
            elif value[1] == 90 or value[1] == 270:

                self.outer_area[value[1]] = (
                    self._est_outer_wall_area / self.nr_of_orientation
                )

            for zone in self.thermal_zones:
                # create wall and set building elements
                outer_wall = OuterWall(zone)
                outer_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                outer_wall.name = key
                outer_wall.tilt = value[0]
                outer_wall.orientation = value[1]

        for key, value in self.window_names.items():

            if value[1] == 0 or value[1] == 180:

                self.window_area[value[1]] = self._est_win_area / self.nr_of_orientation

            elif value[1] == 90 or value[1] == 270:

                self.window_area[value[1]] = self._est_win_area / self.nr_of_orientation

            &#34;&#34;&#34;
            There is no real classification for windows, so this is a bit hard
            code - will be fixed sometime
            &#34;&#34;&#34;
            for zone in self.thermal_zones:
                window = Window(zone)

                window.load_type_element(
                    self.year_of_construction,
                    &#34;Kunststofffenster, &#34; &#34;Isolierverglasung&#34;,
                    data_class=self.parent.data,
                )
                window.name = key
                window.tilt = value[0]
                window.orientation = value[1]

        for key, value in self.roof_names.items():

            self.outer_area[value[1]] = self._est_roof_area

            for zone in self.thermal_zones:
                roof = Rooftop(zone)
                roof.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                roof.name = key
                roof.tilt = value[0]
                roof.orientation = value[1]

        for key, value in self.ground_floor_names.items():

            self.outer_area[value[1]] = self._est_ground_floor_area

            for zone in self.thermal_zones:
                ground_floor = GroundFloor(zone)
                ground_floor.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                ground_floor.name = key
                ground_floor.tilt = value[0]
                ground_floor.orientation = value[1]

        for key, value in self.inner_wall_names.items():

            for zone in self.thermal_zones:
                inner_wall = InnerWall(zone)
                inner_wall.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                inner_wall.name = key
                inner_wall.tilt = value[0]
                inner_wall.orientation = value[1]
                # zone.inner_walls.append(inner_wall)

        if self.number_of_floors &gt; 1:

            for key, value in self.ceiling_names.items():

                for zone in self.thermal_zones:
                    ceiling = Ceiling(zone)
                    ceiling.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    ceiling.name = key
                    ceiling.tilt = value[0]
                    ceiling.orientation = value[1]
                    # zone.inner_walls.append(ceiling)

            for key, value in self.floor_names.items():

                for zone in self.thermal_zones:
                    floor = Floor(zone)
                    floor.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data,
                    )
                    floor.name = key
                    floor.tilt = value[0]
                    floor.orientation = value[1]
                    # zone.inner_walls.append(floor)
        else:
            pass

        for key, value in self.outer_area.items():
            self.set_outer_wall_area(value, key)
        for key, value in self.window_area.items():
            self.set_window_area(value, key)

        for zone in self.thermal_zones:
            zone.set_inner_wall_area()
            zone.set_volume_zone()

    def generate_from_gml(self):
        &#34;&#34;&#34;Enriches lod1 or lod2 data from CityGML

        Adds Zones, BoundaryConditions, Material settings for walls and
        windows to the geometric representation of CityGML

        Enrichment of LoD3 and LoD4 added, parallel to original.
        &#34;&#34;&#34;

        type_bldg_area = self.net_leased_area
        self.net_leased_area = 0.0
        # my variable: decider for inner_wall calculation method
        lod4_innerwalls = False
        # create zones with their corresponding area, name and usage

        for key, value in self.zone_area_factors.items():
            zone = ThermalZone(self)
            zone.area = type_bldg_area * value[0]
            zone.name = key
            use_cond = UseCond(zone)
            use_cond.load_use_conditions(value[1],
                                         data_class=self.parent.data)
            zone.use_conditions = use_cond
            zone.use_conditions.with_ahu = False
            # zone.use_conditions.persons *= zone.area * 0.01
            # zone.use_conditions.machines *= zone.area * 0.01

            # TODO: fix with or without Windows scenario 2

            for surface in self.gml_surfaces:
                if surface.surface_tilt is not None and surface.name is None:
                    if surface.surface_tilt == 90:
                        outer_wall = OuterWall(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                        window = Window(zone)
                        window.load_type_element(self.year_of_construction,
                                                 &#34;Kunststofffenster, &#34;
                                                 &#34;Isolierverglasung&#34;,
                                                 data_class=self.parent.data)
                        window.name = &#34;window&#34; + str(surface.surface_tilt)
                        window.tilt = surface.surface_tilt
                        window.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                    else:
                        outer_wall = Rooftop(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                # If Window / Interior Wall area is provided separately

                else:
                    if surface.surface_tilt == 90:
                        if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                            outer_wall = OuterWall(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation
                        elif surface.name == &#34;Window&#34;:
                            window = Window(zone)
                            window.load_type_element(self.year_of_construction,
                                                     &#34;Kunststofffenster, &#34;
                                                     &#34;Isolierverglasung&#34;,
                                                     data_class=self.parent.data)
                            window.name = surface.name + str(surface.surface_orientation)
                            window.area = surface.surface_area
                            window.tilt = surface.surface_tilt
                            window.orientation = surface.surface_orientation
                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            inner_wall = InnerWall(zone)
                            inner_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            inner_wall.name = surface.name + str(surface.surface_orientation) \
                                                           + str(surface.surface_area)
                            inner_wall.tilt = surface.surface_tilt
                            inner_wall.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                            -2 and surface.name != &#34;InnerWall&#34;:
                        outer_wall = GroundFloor(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation

                    elif surface.surface_tilt == 0 and \
                            surface.surface_orientation == \
                            -2 and surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        floor = Floor(zone)
                        floor.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        floor.name = &#34;floor&#34; + str(surface.surface_orientation) \
                                             + str(surface.surface_area)
                        floor.tilt = surface.surface_tilt
                        floor.orientation = surface.surface_orientation

                    else:
                        if surface.name != &#34;InnerWall&#34;:
                            outer_wall = Rooftop(zone)
                            outer_wall.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            outer_wall.name = surface.name
                            outer_wall.tilt = surface.surface_tilt
                            outer_wall.orientation = surface.surface_orientation

                        elif surface.name == &#34;InnerWall&#34;:
                            lod4_innerwalls = True
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = &#34;ceiling&#34; + str(surface.surface_orientation) \
                                                     + str(surface.surface_area)
                            ceiling.tilt = surface.surface_tilt
                            ceiling.orientation = surface.surface_orientation


            if lod4_innerwalls is False:

                for key, value in self.inner_wall_names.items():
                    for zone in self.thermal_zones:
                        inner_wall = InnerWall(zone)
                        inner_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        inner_wall.name = key
                        inner_wall.tilt = value[0]
                        inner_wall.orientation = value[1]

                if self.number_of_floors &gt; 1:

                    for key, value in self.ceiling_names.items():
                        for zone in self.thermal_zones:
                            ceiling = Ceiling(zone)
                            ceiling.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            ceiling.name = key
                            ceiling.tilt = value[0]
                            ceiling.orientation = value[1]

                    for key, value in self.floor_names.items():
                        for zone in self.thermal_zones:
                            floor = Floor(zone)
                            floor.load_type_element(
                                year=self.year_of_construction,
                                construction=self.construction_type,
                                data_class=self.parent.data)
                            floor.name = key
                            floor.tilt = value[0]
                            floor.orientation = value[1]
                else:
                    pass
            else:
                pass

        for surface in self.gml_surfaces:
            if surface.name is None:                                                       # LoD0-2
                if surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                        and surface.surface_orientation != -1:                              # Walls/Windows
                    # self.set_outer_wall_area(surface.surface_area *
                    #                          (1 - self.est_factor_win_area),
                    #                          surface.surface_orientation)
                    self.set_outer_wall_area(surface.surface_area,
                                             surface.surface_orientation, surface.surface_tilt)
                    self.set_window_area(surface.surface_area*self.est_factor_win_area,
                                         surface.surface_orientation)
                    # self.set_window_area(surface.surface_area,
                    #                      surface.surface_orientation)
                else:                                                                      # Ground/Floor
                    self.set_outer_wall_area(surface.surface_area,
                                             surface.surface_orientation, surface.surface_tilt)
            else:                                                                          # LoD3-4
                if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                    self.set_outer_wall_area(surface.surface_area, surface.surface_orientation, surface.surface_tilt)
                elif surface.name == &#34;Window&#34;:

                    # TODO: fix window area calc in here or in building.py: sum before attribution!?

                    self.set_window_area(surface.surface_area, surface.surface_orientation)
                elif surface.name == &#34;InnerWall&#34;:
                    self.set_inner_wall_area_lod4(surface.surface_area, surface.surface_orientation)

        if lod4_innerwalls is False:
            for zone in self.thermal_zones:
                zone.set_inner_wall_area()
                zone.set_volume_zone()
        else:
            for zone in self.thermal_zones:
                zone.set_volume_zone()

    @property
    def residential_layout(self):
        return self._residential_layout

    @residential_layout.setter
    def residential_layout(self, value):
        if value is not None:
            self._residential_layout = value
        else:
            self._residential_layout = 0

    @property
    def neighbour_buildings(self):
        return self._neighbour_buildings

    @neighbour_buildings.setter
    def neighbour_buildings(self, value):
        if value is not None:
            self._neighbour_buildings = value
        else:
            self._neighbour_buildings = 0

    @property
    def attic(self):
        return self._attic

    @attic.setter
    def attic(self, value):
        if value is not None:
            self._attic = value
        else:
            self._attic = 0

    @property
    def cellar(self):
        return self._cellar

    @cellar.setter
    def cellar(self, value):
        if value is not None:
            self._cellar = value
        else:
            self._cellar = 0

    @property
    def dormer(self):
        return self._dormer

    @dormer.setter
    def dormer(self, value):
        if value is not None:
            self._dormer = value
        else:
            self._dormer = 0

    @property
    def construction_type(self):
        return self._construction_type

    @construction_type.setter
    def construction_type(self, value):
        if value is not None:
            if value == &#34;heavy&#34; or value == &#34;light&#34;:
                self._construction_type = value
            else:
                raise ValueError(&#34;Construction_type has to be light or heavy&#34;)
        else:
            self._construction_type = &#34;heavy&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="teaser.logic.archetypebuildings.residential.Residential" href="../residential.html#teaser.logic.archetypebuildings.residential.Residential">Residential</a></li>
<li><a title="teaser.logic.buildingobjects.building.Building" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building">Building</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.attic"><code class="name">var <span class="ident">attic</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attic(self):
    return self._attic</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.cellar"><code class="name">var <span class="ident">cellar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cellar(self):
    return self._cellar</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.construction_type"><code class="name">var <span class="ident">construction_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def construction_type(self):
    return self._construction_type</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.dormer"><code class="name">var <span class="ident">dormer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dormer(self):
    return self._dormer</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.neighbour_buildings"><code class="name">var <span class="ident">neighbour_buildings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def neighbour_buildings(self):
    return self._neighbour_buildings</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.residential_layout"><code class="name">var <span class="ident">residential_layout</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def residential_layout(self):
    return self._residential_layout</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.generate_archetype"><code class="name flex">
<span>def <span class="ident">generate_archetype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a SingleFamilyDwelling building.</p>
<p>With given values, this class generates a archetype building for
single family dwellings according to TEASER requirements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_archetype(self):
    &#34;&#34;&#34;Generates a SingleFamilyDwelling building.

    With given values, this class generates a archetype building for
    single family dwellings according to TEASER requirements
    &#34;&#34;&#34;
    # help area for the correct building area setting while using typeBldgs
    self.thermal_zones = None
    type_bldg_area = self.net_leased_area
    self.net_leased_area = 0.0

    self._number_of_heated_floors = (
        self._est_factor_heated_cellar
        + self.number_of_floors
        + self.est_living_area_factor * self._est_factor_heated_attic
    )

    self._living_area_per_floor = type_bldg_area / self._number_of_heated_floors

    self._est_ground_floor_area = (
        self.est_bottom_building_closure * self._living_area_per_floor
    )

    self._est_roof_area = (
        self.est_upper_building_closure
        * self._est_factor_dormer
        * self._est_area_per_floor
        * self._living_area_per_floor
    )

    self._top_floor_area = self._est_area_per_roof * self._living_area_per_floor

    if self._est_roof_area == 0:
        self._est_roof_area = self._top_floor_area

    self._est_facade_area = self._est_facade_to_floor_area * (
        self._living_area_per_floor + self._est_extra_floor_area
    )

    self._est_win_area = self.est_factor_win_area * type_bldg_area

    self._est_cellar_wall_area = (
        self.est_factor_cellar_area
        * self._est_factor_heated_cellar
        * self._est_facade_area
    )

    self._est_outer_wall_area = (
        (self._number_of_heated_floors * self._est_facade_area)
        - self._est_cellar_wall_area
        - self._est_win_area
    )

    # self._est_factor_volume = type_bldg_area * 2.5

    for key, value in self.zone_area_factors.items():
        zone = ThermalZone(self)
        zone.name = key
        zone.area = type_bldg_area * value[0]
        use_cond = UseCond(zone)
        use_cond.load_use_conditions(value[1], data_class=self.parent.data)

        zone.use_conditions = use_cond
        zone.use_conditions.with_ahu = False

    for key, value in self.outer_wall_names.items():
        # North and South

        if value[1] == 0 or value[1] == 180.0:
            self.outer_area[value[1]] = (
                self._est_outer_wall_area / self.nr_of_orientation
            )
        # East and West
        elif value[1] == 90 or value[1] == 270:

            self.outer_area[value[1]] = (
                self._est_outer_wall_area / self.nr_of_orientation
            )

        for zone in self.thermal_zones:
            # create wall and set building elements
            outer_wall = OuterWall(zone)
            outer_wall.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            outer_wall.name = key
            outer_wall.tilt = value[0]
            outer_wall.orientation = value[1]

    for key, value in self.window_names.items():

        if value[1] == 0 or value[1] == 180:

            self.window_area[value[1]] = self._est_win_area / self.nr_of_orientation

        elif value[1] == 90 or value[1] == 270:

            self.window_area[value[1]] = self._est_win_area / self.nr_of_orientation

        &#34;&#34;&#34;
        There is no real classification for windows, so this is a bit hard
        code - will be fixed sometime
        &#34;&#34;&#34;
        for zone in self.thermal_zones:
            window = Window(zone)

            window.load_type_element(
                self.year_of_construction,
                &#34;Kunststofffenster, &#34; &#34;Isolierverglasung&#34;,
                data_class=self.parent.data,
            )
            window.name = key
            window.tilt = value[0]
            window.orientation = value[1]

    for key, value in self.roof_names.items():

        self.outer_area[value[1]] = self._est_roof_area

        for zone in self.thermal_zones:
            roof = Rooftop(zone)
            roof.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            roof.name = key
            roof.tilt = value[0]
            roof.orientation = value[1]

    for key, value in self.ground_floor_names.items():

        self.outer_area[value[1]] = self._est_ground_floor_area

        for zone in self.thermal_zones:
            ground_floor = GroundFloor(zone)
            ground_floor.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            ground_floor.name = key
            ground_floor.tilt = value[0]
            ground_floor.orientation = value[1]

    for key, value in self.inner_wall_names.items():

        for zone in self.thermal_zones:
            inner_wall = InnerWall(zone)
            inner_wall.load_type_element(
                year=self.year_of_construction,
                construction=self.construction_type,
                data_class=self.parent.data,
            )
            inner_wall.name = key
            inner_wall.tilt = value[0]
            inner_wall.orientation = value[1]
            # zone.inner_walls.append(inner_wall)

    if self.number_of_floors &gt; 1:

        for key, value in self.ceiling_names.items():

            for zone in self.thermal_zones:
                ceiling = Ceiling(zone)
                ceiling.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                ceiling.name = key
                ceiling.tilt = value[0]
                ceiling.orientation = value[1]
                # zone.inner_walls.append(ceiling)

        for key, value in self.floor_names.items():

            for zone in self.thermal_zones:
                floor = Floor(zone)
                floor.load_type_element(
                    year=self.year_of_construction,
                    construction=self.construction_type,
                    data_class=self.parent.data,
                )
                floor.name = key
                floor.tilt = value[0]
                floor.orientation = value[1]
                # zone.inner_walls.append(floor)
    else:
        pass

    for key, value in self.outer_area.items():
        self.set_outer_wall_area(value, key)
    for key, value in self.window_area.items():
        self.set_window_area(value, key)

    for zone in self.thermal_zones:
        zone.set_inner_wall_area()
        zone.set_volume_zone()</code></pre>
</details>
</dd>
<dt id="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.generate_from_gml"><code class="name flex">
<span>def <span class="ident">generate_from_gml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enriches lod1 or lod2 data from CityGML</p>
<p>Adds Zones, BoundaryConditions, Material settings for walls and
windows to the geometric representation of CityGML</p>
<p>Enrichment of LoD3 and LoD4 added, parallel to original.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_from_gml(self):
    &#34;&#34;&#34;Enriches lod1 or lod2 data from CityGML

    Adds Zones, BoundaryConditions, Material settings for walls and
    windows to the geometric representation of CityGML

    Enrichment of LoD3 and LoD4 added, parallel to original.
    &#34;&#34;&#34;

    type_bldg_area = self.net_leased_area
    self.net_leased_area = 0.0
    # my variable: decider for inner_wall calculation method
    lod4_innerwalls = False
    # create zones with their corresponding area, name and usage

    for key, value in self.zone_area_factors.items():
        zone = ThermalZone(self)
        zone.area = type_bldg_area * value[0]
        zone.name = key
        use_cond = UseCond(zone)
        use_cond.load_use_conditions(value[1],
                                     data_class=self.parent.data)
        zone.use_conditions = use_cond
        zone.use_conditions.with_ahu = False
        # zone.use_conditions.persons *= zone.area * 0.01
        # zone.use_conditions.machines *= zone.area * 0.01

        # TODO: fix with or without Windows scenario 2

        for surface in self.gml_surfaces:
            if surface.surface_tilt is not None and surface.name is None:
                if surface.surface_tilt == 90:
                    outer_wall = OuterWall(zone)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation
                    window = Window(zone)
                    window.load_type_element(self.year_of_construction,
                                             &#34;Kunststofffenster, &#34;
                                             &#34;Isolierverglasung&#34;,
                                             data_class=self.parent.data)
                    window.name = &#34;window&#34; + str(surface.surface_tilt)
                    window.tilt = surface.surface_tilt
                    window.orientation = surface.surface_orientation

                elif surface.surface_tilt == 0 and \
                    surface.surface_orientation == \
                        -2:
                    outer_wall = GroundFloor(zone)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation
                else:
                    outer_wall = Rooftop(zone)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation
            # If Window / Interior Wall area is provided separately

            else:
                if surface.surface_tilt == 90:
                    if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                        outer_wall = OuterWall(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation
                    elif surface.name == &#34;Window&#34;:
                        window = Window(zone)
                        window.load_type_element(self.year_of_construction,
                                                 &#34;Kunststofffenster, &#34;
                                                 &#34;Isolierverglasung&#34;,
                                                 data_class=self.parent.data)
                        window.name = surface.name + str(surface.surface_orientation)
                        window.area = surface.surface_area
                        window.tilt = surface.surface_tilt
                        window.orientation = surface.surface_orientation
                    elif surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        inner_wall = InnerWall(zone)
                        inner_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        inner_wall.name = surface.name + str(surface.surface_orientation) \
                                                       + str(surface.surface_area)
                        inner_wall.tilt = surface.surface_tilt
                        inner_wall.orientation = surface.surface_orientation

                elif surface.surface_tilt == 0 and \
                    surface.surface_orientation == \
                        -2 and surface.name != &#34;InnerWall&#34;:
                    outer_wall = GroundFloor(zone)
                    outer_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    outer_wall.name = surface.name
                    outer_wall.tilt = surface.surface_tilt
                    outer_wall.orientation = surface.surface_orientation

                elif surface.surface_tilt == 0 and \
                        surface.surface_orientation == \
                        -2 and surface.name == &#34;InnerWall&#34;:
                    lod4_innerwalls = True
                    floor = Floor(zone)
                    floor.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    floor.name = &#34;floor&#34; + str(surface.surface_orientation) \
                                         + str(surface.surface_area)
                    floor.tilt = surface.surface_tilt
                    floor.orientation = surface.surface_orientation

                else:
                    if surface.name != &#34;InnerWall&#34;:
                        outer_wall = Rooftop(zone)
                        outer_wall.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        outer_wall.name = surface.name
                        outer_wall.tilt = surface.surface_tilt
                        outer_wall.orientation = surface.surface_orientation

                    elif surface.name == &#34;InnerWall&#34;:
                        lod4_innerwalls = True
                        ceiling = Ceiling(zone)
                        ceiling.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        ceiling.name = &#34;ceiling&#34; + str(surface.surface_orientation) \
                                                 + str(surface.surface_area)
                        ceiling.tilt = surface.surface_tilt
                        ceiling.orientation = surface.surface_orientation


        if lod4_innerwalls is False:

            for key, value in self.inner_wall_names.items():
                for zone in self.thermal_zones:
                    inner_wall = InnerWall(zone)
                    inner_wall.load_type_element(
                        year=self.year_of_construction,
                        construction=self.construction_type,
                        data_class=self.parent.data)
                    inner_wall.name = key
                    inner_wall.tilt = value[0]
                    inner_wall.orientation = value[1]

            if self.number_of_floors &gt; 1:

                for key, value in self.ceiling_names.items():
                    for zone in self.thermal_zones:
                        ceiling = Ceiling(zone)
                        ceiling.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        ceiling.name = key
                        ceiling.tilt = value[0]
                        ceiling.orientation = value[1]

                for key, value in self.floor_names.items():
                    for zone in self.thermal_zones:
                        floor = Floor(zone)
                        floor.load_type_element(
                            year=self.year_of_construction,
                            construction=self.construction_type,
                            data_class=self.parent.data)
                        floor.name = key
                        floor.tilt = value[0]
                        floor.orientation = value[1]
            else:
                pass
        else:
            pass

    for surface in self.gml_surfaces:
        if surface.name is None:                                                       # LoD0-2
            if surface.surface_tilt != 0 and surface.surface_orientation != -2 \
                    and surface.surface_orientation != -1:                              # Walls/Windows
                # self.set_outer_wall_area(surface.surface_area *
                #                          (1 - self.est_factor_win_area),
                #                          surface.surface_orientation)
                self.set_outer_wall_area(surface.surface_area,
                                         surface.surface_orientation, surface.surface_tilt)
                self.set_window_area(surface.surface_area*self.est_factor_win_area,
                                     surface.surface_orientation)
                # self.set_window_area(surface.surface_area,
                #                      surface.surface_orientation)
            else:                                                                      # Ground/Floor
                self.set_outer_wall_area(surface.surface_area,
                                         surface.surface_orientation, surface.surface_tilt)
        else:                                                                          # LoD3-4
            if surface.name != &#34;Window&#34; and surface.name != &#34;InnerWall&#34;:
                self.set_outer_wall_area(surface.surface_area, surface.surface_orientation, surface.surface_tilt)
            elif surface.name == &#34;Window&#34;:

                # TODO: fix window area calc in here or in building.py: sum before attribution!?

                self.set_window_area(surface.surface_area, surface.surface_orientation)
            elif surface.name == &#34;InnerWall&#34;:
                self.set_inner_wall_area_lod4(surface.surface_area, surface.surface_orientation)

    if lod4_innerwalls is False:
        for zone in self.thermal_zones:
            zone.set_inner_wall_area()
            zone.set_volume_zone()
    else:
        for zone in self.thermal_zones:
            zone.set_volume_zone()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="teaser.logic.archetypebuildings.residential.Residential" href="../residential.html#teaser.logic.archetypebuildings.residential.Residential">Residential</a></b></code>:
<ul class="hlist">
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.add_lca_data_elec" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_lca_data_elec">add_lca_data_elec</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.add_lca_data_heating" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_lca_data_heating">add_lca_data_heating</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.add_lca_data_template" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_lca_data_template">add_lca_data_template</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.add_zone" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.add_zone">add_zone</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.calc_building_parameter" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.calc_building_parameter">calc_building_parameter</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.calc_lca_data" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.calc_lca_data">calc_lca_data</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.est_elec_demand" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.est_elec_demand">est_elec_demand</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.fill_outer_area_dict" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.fill_outer_area_dict">fill_outer_area_dict</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.fill_window_area_dict" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.fill_window_area_dict">fill_window_area_dict</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.get_footprint_gml" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_footprint_gml">get_footprint_gml</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.get_inner_wall_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_inner_wall_area">get_inner_wall_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.get_outer_wall_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_outer_wall_area">get_outer_wall_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.get_window_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.get_window_area">get_window_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.print_be_information" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.print_be_information">print_be_information</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.retrofit_building" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.retrofit_building">retrofit_building</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.rotate_building" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.rotate_building">rotate_building</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.set_gml_attributes" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_gml_attributes">set_gml_attributes</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.set_height_gml" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_height_gml">set_height_gml</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.set_outer_wall_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_outer_wall_area">set_outer_wall_area</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.residential.Residential.set_window_area" href="../../buildingobjects/building.html#teaser.logic.buildingobjects.building.Building.set_window_area">set_window_area</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs" href="index.html">teaser.logic.archetypebuildings.bmvbs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling">SingleFamilyDwelling</a></code></h4>
<ul class="two-column">
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.attic" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.attic">attic</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.cellar" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.cellar">cellar</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.construction_type" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.construction_type">construction_type</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.dormer" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.dormer">dormer</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.generate_archetype" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.generate_archetype">generate_archetype</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.generate_from_gml" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.generate_from_gml">generate_from_gml</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.neighbour_buildings" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.neighbour_buildings">neighbour_buildings</a></code></li>
<li><code><a title="teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.residential_layout" href="#teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling.SingleFamilyDwelling.residential_layout">residential_layout</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>