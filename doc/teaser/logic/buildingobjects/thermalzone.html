<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>teaser.logic.buildingobjects.thermalzone API documentation</title>
<meta name="description" content="This module includes the ThermalZone class" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>teaser.logic.buildingobjects.thermalzone</code></h1>
</header>
<section id="section-intro">
<p>This module includes the ThermalZone class</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># created June 2015
# by TEASER4 Development Team

&#34;&#34;&#34;This module includes the ThermalZone class
&#34;&#34;&#34;
from __future__ import division
import random
import re
import warnings
import uuid
from teaser.logic.buildingobjects.calculation.one_element import OneElement
from teaser.logic.buildingobjects.calculation.two_element import TwoElement
from teaser.logic.buildingobjects.calculation.three_element import ThreeElement
from teaser.logic.buildingobjects.calculation.four_element import FourElement
from teaser.logic.buildingobjects.buildingphysics.en15804lcadata import En15804LcaData


class ThermalZone(object):
    &#34;&#34;&#34;Thermal zone class.

    This class is used to manage information and parameter calculation for
    thermal zones. Each thermal zone has one specific calculation method,
    which is specific to the used model (model_attr). For new model
    implementation this attribute can be assigned to new classes.

    Parameters
    ----------
    parent: Building()
        The parent class of this object, the Building the zone belongs to.
        Allows for better control of hierarchical structures. If not None it
        adds this ThermalZone instance to Building.thermal_zones.
        Default is None

    Attributes
    ----------

    internal_id : float
        Random id for the distinction between different zones.
    name : str
        Individual name.
    area : float [m2]
        Thermal zone area.
    volume : float [m3]
        Thermal zone volume.
    outer_walls : list
        List of OuterWall instances.
    doors : list
        List of Door instances.
    rooftops : list
        List of Rooftop instances.
    ground_floors : list
        List of GroundFloor instances.
    windows : list
        List of Window instances.
    inner_walls : list
        List of InnerWall instances.
    floors : list
        List of Floor instances.
    ceilings: list
        List of Ceiling instances.
    use_conditions : instance of UseConditions()
        Instance of UseConditions with all relevant information for the usage
        of the thermal zone
    model_attr : instance of OneElement(), TwoElement(), ThreeElement() or
                FourElement()
        Instance of OneElement(), TwoElement(), ThreeElement() or
        FourElement(), that holds all calculation functions and attributes
        needed for the specific model.
    t_inside : float [K]
        Normative indoor temperature for static heat load calculation.
        The input of t_inside is ALWAYS in Kelvin
    t_outside : float [K]
        Normative outdoor temperature for static heat load calculation.
        The input of t_inside is ALWAYS in Kelvin
    t_ground : float [K]
        Temperature directly at the outer side of ground floors for static
        heat load calculation.
        The input of t_ground is ALWAYS in Kelvin
    density_air : float [kg/m3]
        average density of the air in the thermal zone
    heat_capac_air : float [J/K]
        average heat capacity of the air in the thermal zone
    
    lca_data : En15804LcaData
        enviromental indicator of the thermalzone. The data referencing to
        one thermalzone
    &#34;&#34;&#34;

    def __init__(self, parent=None):
        &#34;&#34;&#34;Constructor for ThermalZone
        &#34;&#34;&#34;

        self.parent = parent

        self.internal_id = uuid.uuid1()
        self.name = None
        self._area = None
        self._volume = None
        self._infiltration_rate = 0.4
        self._outer_walls = []
        self._doors = []
        self._rooftops = []
        self._ground_floors = []
        self._windows = []
        self._inner_walls = []
        self._floors = []
        self._ceilings = []
        self._use_conditions = None
        self._t_inside = 293.15
        self._t_outside = 261.15
        self.density_air = 1.25
        self.heat_capac_air = 1002
        self.t_ground = 286.15
        
        self._lca_data = None

    def calc_zone_parameters(
            self,
            number_of_elements=2,
            merge_windows=False,
            t_bt=5):
        &#34;&#34;&#34;RC-Calculation for the thermal zone

        Based on the input parameters (used model) this function instantiates
        the corresponding calculation Class (e.g. TwoElement) and calculates
        the zone parameters. Currently the function is able to distinguishes
        between the number of elements, we distinguish between:
            - one element: all outer walls are aggregated into one element,
            inner wall are neglected
            - two elements: exterior and interior walls are aggregated
            - three elements: like 2, but floor or roofs are aggregated
            separately
            - four elements: roofs and floors are aggregated separately

        For all four options we can chose if the thermal conduction through
        the window is considered in a separate resistance or not.

        Parameters
        ----------
        number_of_elements : int
            defines the number of elements, that area aggregated, between 1
            and 4, default is 2

        merge_windows : bool
            True for merging the windows into the outer walls, False for
            separate resistance for window, default is False (Only
            supported for IBPSA)

        t_bt : float
            Time constant according to VDI 6007 (default t_bt = 5)
        &#34;&#34;&#34;

        if number_of_elements == 1:
            self.model_attr = OneElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()
        elif number_of_elements == 2:
            self.model_attr = TwoElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()
        elif number_of_elements == 3:
            self.model_attr = ThreeElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()
        elif number_of_elements == 4:
            self.model_attr = FourElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()

    def find_walls(self, orientation, tilt):
        &#34;&#34;&#34;Returns all outer walls with given orientation and tilt

        This function returns a list of all OuterWall elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired walls.
        tilt : float [degree]
            Tilt against the horizontal of the desired walls.

        Returns
        -------
        elements : list
            List of OuterWalls instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.outer_walls:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_doors(self, orientation, tilt):
        &#34;&#34;&#34;Returns all outer walls with given orientation and tilt

        This function returns a list of all Doors elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired walls.
        tilt : float [degree]
            Tilt against the horizontal of the desired walls.

        Returns
        -------
        elements : list
            List of Doors instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.doors:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_rts(self, orientation, tilt):
        &#34;&#34;&#34;Returns all rooftops with given orientation and tilt

        This function returns a list of all Rooftop elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired rooftops.
        tilt : float [degree]
            Tilt against the horizontal of the desired rooftops.

        Returns
        -------
        elements : list
            List of Rooftop instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.rooftops:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_gfs(self, orientation, tilt):
        &#34;&#34;&#34;Returns all ground floors with given orientation and tilt

        This function returns a list of all GroundFloor elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired ground floors.
        tilt : float [degree]
            Tilt against the horizontal of the desired ground floors.

        Returns
        -------
        elements : list
            List of GroundFloor instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.ground_floors:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_wins(self, orientation, tilt):
        &#34;&#34;&#34;Returns all windows with given orientation and tilt

        This function returns a list of all Window elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired windows.
        tilt : float [degree]
            Tilt against the horizontal of the desired windows.

        Returns
        -------
        elements : list
            List of Window instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.windows:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def set_inner_wall_area(self):
        &#34;&#34;&#34;Sets the inner wall area according to zone area

        Sets the inner wall area according to zone area size if type building
        approach is used. This function covers Floors, Ceilings and InnerWalls.
        &#34;&#34;&#34;

        ass_error_1 = &#34;You need to specify parent for thermal zone&#34;

        assert self.parent is not None, ass_error_1

        for floor in self.floors:
            floor.area = (
                (self.parent.number_of_floors - 1) /
                self.parent.number_of_floors) * self.area
        for ceiling in self.ceilings:
            ceiling.area = (
                (self.parent.number_of_floors - 1) /
                self.parent.number_of_floors) * self.area

        for wall in self.inner_walls:
            typical_area = self.use_conditions.typical_length * \
                self.use_conditions.typical_width

            avg_room_nr = self.area / typical_area

            wall.area = (avg_room_nr * (self.use_conditions.typical_length *
                                        self.parent.height_of_floors +
                                        2 * self.use_conditions.typical_width *
                                        self.parent.height_of_floors))

    def set_volume_zone(self):
        &#34;&#34;&#34;Sets the zone volume according to area and height of floors

        Sets the volume of a zone according area and height of floors
        (building attribute).
        &#34;&#34;&#34;

        ass_error_1 = &#34;you need to specify parent for thermal zone&#34;

        assert self.parent is not None, ass_error_1

        self.volume = self.area * self.parent.height_of_floors

    def retrofit_zone(
            self,
            type_of_retrofit=None,
            window_type=None,
            material=None):
        &#34;&#34;&#34;Retrofits all walls and windows in the zone.

        Function call for all elements facing the ambient or ground.
        Distinguishes if the parent building is a archetype of type &#39;iwu&#39; or
        &#39;tabula_de&#39;. If TABULA is used, it will use the pre-defined wall
        constructions of TABULA.

        This function covers OuterWall, Rooftop, GroundFloor and Window.

        Parameters
        ----------
        type_of_retrofit : str
            The classification of retrofit, if the archetype building
            approach of TABULA is used.
        window_type : str
            Default: EnEv 2014
        material : str
            Default: EPS035
        &#34;&#34;&#34;

        if type_of_retrofit is None:
            type_of_retrofit = &#39;retrofit&#39;

        if type(self.parent).__name__ in [
            &#34;SingleFamilyHouse&#34;, &#34;TerracedHouse&#34;, &#34;MultiFamilyHouse&#34;,
                &#34;ApartmentBlock&#34;]:
            for wall_count in self.outer_walls \
                    + self.rooftops + self.ground_floors + self.doors + \
                    self.windows:
                if &#34;adv_retrofit&#34; in wall_count.construction_type:
                    warnings.warn(
                        &#34;already highest available standard&#34;
                        + self.parent.name + wall_count.name)
                elif &#34;standard&#34; in wall_count.construction_type:
                    wall_count.load_type_element(
                        year=self.parent.year_of_construction,
                        construction=wall_count.construction_type.replace(
                            &#34;standard&#34;, type_of_retrofit))
                else:
                    wall_count.load_type_element(
                        year=self.parent.year_of_construction,
                        construction=wall_count.construction_type.replace(
                            &#34;retrofit&#34;, type_of_retrofit))
        else:

            for wall_count in self.outer_walls:
                wall_count.retrofit_wall(
                    self.parent.year_of_retrofit,
                    material)
            for roof_count in self.rooftops:
                roof_count.retrofit_wall(
                    self.parent.year_of_retrofit,
                    material)
            for ground_count in self.ground_floors:
                ground_count.retrofit_wall(
                    self.parent.year_of_retrofit,
                    material)
            for win_count in self.windows:
                win_count.replace_window(
                    self.parent.year_of_retrofit,
                    window_type)

    def delete(self):
        &#34;&#34;&#34;Deletes the actual thermal zone safely.

        This deletes the current thermal Zone and also refreshes the
        thermal_zones list in the parent Building.
        &#34;&#34;&#34;
        for index, tz in enumerate(self.parent.thermal_zones):
            if tz.internal_id == self.internal_id:
                self.parent.net_leased_area -= self.area
                self.parent.thermal_zones.pop(index)

                break

    def add_element(self, building_element):
        &#34;&#34;&#34;Adds a building element to the corresponding list

        This function adds a BuildingElement instance to the the list
        depending on the type of the Building Element

        Parameters
        ----------
        building_element : BuildingElement()
            inherited objects of BuildingElement() instance of TEASER

        &#34;&#34;&#34;

        ass_error_1 = (&#34;building_element has to be an instance of OuterWall,&#34;
                       &#34; Rooftop, GroundFloor, Window, InnerWall, &#34;
                       &#34;Ceiling or Floor&#34;)

        assert type(building_element).__name__ in (
            &#34;OuterWall&#34;, &#34;Rooftop&#34;, &#34;GroundFloor&#34;,
            &#34;InnerWall&#34;, &#34;Ceiling&#34;, &#34;Floor&#34;,
            &#34;Window&#34;), ass_error_1

        if type(building_element).__name__ == &#34;OuterWall&#34;:
            self._outer_walls.append(building_element)
        elif type(building_element).__name__ == &#34;GroundFloor&#34;:
            self._ground_floors.append(building_element)
        elif type(building_element).__name__ == &#34;Rooftop&#34;:
            self._rooftops.append(building_element)
        elif type(building_element).__name__ == &#34;InnerWall&#34;:
            self._inner_walls.append(building_element)
        elif type(building_element).__name__ == &#34;Ceiling&#34;:
            self._ceilings.append(building_element)
        elif type(building_element).__name__ == &#34;Floor&#34;:
            self._floors.append(building_element)
        elif type(building_element).__name__ == &#34;Window&#34;:
            self._windows.append(building_element)

    @property
    def parent(self):
        return self.__parent

    @parent.setter
    def parent(self, value):
        from teaser.logic.buildingobjects.building import Building
        import inspect
        if value is not None:
            if inspect.isclass(Building):
                self.__parent = value
                self.__parent.thermal_zones.append(self)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            regex = re.compile(&#39;[^a-zA-z0-9]&#39;)
            self._name = regex.sub(&#39;&#39;, value)
        else:
            try:
                value = str(value)
                regex = re.compile(&#39;[^a-zA-z0-9]&#39;)
                self._name = regex.sub(&#39;&#39;, value)

            except ValueError:
                print(&#34;Can&#39;t convert name to string&#34;)

    @property
    def outer_walls(self):
        return self._outer_walls

    @outer_walls.setter
    def outer_walls(self, value):
        if value is None:
            self._outer_walls = []

    @property
    def doors(self):
        return self._doors

    @doors.setter
    def doors(self, value):
        if value is None:
            self._doors = []

    @property
    def rooftops(self):
        return self._rooftops

    @rooftops.setter
    def rooftops(self, value):
        if value is None:
            self._rooftops = []

    @property
    def ground_floors(self):
        return self._ground_floors

    @ground_floors.setter
    def ground_floors(self, value):
        if value is None:
            self._ground_floors = []

    @property
    def ceilings(self):
        return self._ceilings

    @ceilings.setter
    def ceilings(self, value):
        if value is None:
            self._ceilings = []

    @property
    def floors(self):
        return self._floors

    @floors.setter
    def floors(self, value):
        if value is None:
            self._floors = []

    @property
    def inner_walls(self):
        return self._inner_walls

    @inner_walls.setter
    def inner_walls(self, value):

        if value is None:
            self._inner_walls = []

    @property
    def windows(self):
        return self._windows

    @windows.setter
    def windows(self, value):

        if value is None:
            self._windows = []

    @property
    def use_conditions(self):
        return self._use_conditions

    @use_conditions.setter
    def use_conditions(self, value):
        ass_error_1 = &#34;Use condition has to be an instance of UseConditions()&#34;

        assert type(value).__name__ == &#34;UseConditions&#34;, ass_error_1

        if value is not None:
            self._use_conditions = value
            self.typical_length = value.typical_length
            self.typical_width = value.typical_width
        self._use_conditions = value

    @property
    def area(self):
        return self._area

    @area.setter
    def area(self, value):

        if isinstance(value, float):
            pass
        elif value is None:
            pass
        else:
            try:
                value = float(value)
            except:
                raise ValueError(&#34;Can&#39;t convert zone area to float&#34;)

        if self.parent is not None:
            if self._area is None:
                if self.parent.net_leased_area is None:
                    self.parent.net_leased_area = 0.0
                self._area = value
                self.parent.net_leased_area += value
            else:
                self.parent.net_leased_area -= self._area
                self.parent.net_leased_area += value
                self._area = value
        else:
            self._area = value

    @property
    def volume(self):
        return self._volume

    @volume.setter
    def volume(self, value):

        if isinstance(value, float):
            pass
        elif value is None:
            pass
        else:
            try:
                value = float(value)
            except ValueError:
                raise ValueError(&#34;Can&#39;t convert zone volume to float&#34;)

        if self.parent is not None:
            if self._volume is None:
                self._volume = value
                self.parent.volume += value
            else:
                self.parent.volume -= self._volume
                self.parent.volume += value
                self._volume = value
        else:
            self._volume = value

    @property
    def infiltration_rate(self):
        warnings.warn(
            &#34;Deprecated for ThermalZone, moved to UseConditions&#34;,
            DeprecationWarning)

    @infiltration_rate.setter
    def infiltration_rate(self, value):
        warnings.warn(
            &#34;Deprecated for ThermalZone, moved to UseConditions&#34;,
            DeprecationWarning)

    @property
    def t_inside(self):
        return self._t_inside

    @t_inside.setter
    def t_inside(self, value):
        if isinstance(value, float):
            self._t_inside = value
        elif value is None:
            self._t_inside = value
        else:
            try:
                value = float(value)
                self._t_inside = value
            except:
                raise ValueError(&#34;Can&#39;t convert temperature to float&#34;)

    @property
    def t_outside(self):
        return self._t_outside

    @t_outside.setter
    def t_outside(self, value):

        if isinstance(value, float):
            self._t_outside = value
        elif value is None:
            self._t_outside = value
        else:
            try:
                value = float(value)
                self._t_outside = value
            except:
                raise ValueError(&#34;Can&#39;t convert temperature to float&#34;)
                
    @property
    def lca_data(self):
        return self._lca_data

    @lca_data.setter
    def lca_data(self, value):
        self._lca_data = value
        
    def get_buildingelements(self):
        &#34;&#34;&#34;returns a list of all buildingelements of the thermalzone
        

        Returns
        -------
        building_elements : list

        &#34;&#34;&#34;
        building_elements = []
        
        building_elements.extend(self.outer_walls)
        building_elements.extend(self.ground_floors)
        building_elements.extend(self.rooftops)
        building_elements.extend(self.inner_walls)
        building_elements.extend(self.floors)
        building_elements.extend(self.windows)
        building_elements.extend(self.ceilings)
        
        return building_elements

    def calc_lca_data(self, use_b4 = None, period_lca_scenario = None):
        &#34;&#34;&#34;sums up every LCA-data from building elements oft he thermalzone.
 
    
        Parameters
        ----------
        use_b4 : bool, optional
            if true all replaced materials and building elements are added to
            stage B4. The default is None.
        period_lca_scenario : int [a], optional
            period of use taken into account for LCA.

        &#34;&#34;&#34;
        lca_data = En15804LcaData()
        
        if use_b4 is None:
            try:
                use_b4 = self.parent.parent.parent.use_b4
            except:
                use_b4 = False
        
        if period_lca_scenario == None:
            try:
                period_lca_scenario = self.parent.parent.parent.period_lca_scenario
            except:
                print(&#34;Please enter a period for the LCA-scenario!&#34;)
                
        building_elements = self.get_buildingelements()
        
        for building_element in building_elements:

            try:
                building_element.calc_lca_data(use_b4, period_lca_scenario)
                lca_data = lca_data + building_element.lca_data
            except:
                print(&#34;Error while adding {}&#34;.format(type(building_element).__name__))
            
        self.lca_data = lca_data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone"><code class="flex name class">
<span>class <span class="ident">ThermalZone</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Thermal zone class.</p>
<p>This class is used to manage information and parameter calculation for
thermal zones. Each thermal zone has one specific calculation method,
which is specific to the used model (model_attr). For new model
implementation this attribute can be assigned to new classes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>Building()</code></dt>
<dd>The parent class of this object, the Building the zone belongs to.
Allows for better control of hierarchical structures. If not None it
adds this ThermalZone instance to Building.thermal_zones.
Default is None</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>internal_id</code></strong> :&ensp;<code>float</code></dt>
<dd>Random id for the distinction between different zones.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Individual name.</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>float [m2]</code></dt>
<dd>Thermal zone area.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>float [m3]</code></dt>
<dd>Thermal zone volume.</dd>
<dt><strong><code>outer_walls</code></strong> :&ensp;<code>list</code></dt>
<dd>List of OuterWall instances.</dd>
<dt><strong><code>doors</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Door instances.</dd>
<dt><strong><code>rooftops</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Rooftop instances.</dd>
<dt><strong><code>ground_floors</code></strong> :&ensp;<code>list</code></dt>
<dd>List of GroundFloor instances.</dd>
<dt><strong><code>windows</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Window instances.</dd>
<dt><strong><code>inner_walls</code></strong> :&ensp;<code>list</code></dt>
<dd>List of InnerWall instances.</dd>
<dt><strong><code>floors</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Floor instances.</dd>
<dt><strong><code>ceilings</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Ceiling instances.</dd>
<dt><strong><code>use_conditions</code></strong> :&ensp;<code>instance</code> of <code>UseConditions()</code></dt>
<dd>Instance of UseConditions with all relevant information for the usage
of the thermal zone</dd>
<dt><strong><code>model_attr</code></strong> :&ensp;<code>instance</code> of <code>OneElement(), TwoElement(), ThreeElement() or</code></dt>
<dd>FourElement()
Instance of OneElement(), TwoElement(), ThreeElement() or
FourElement(), that holds all calculation functions and attributes
needed for the specific model.</dd>
<dt><strong><code>t_inside</code></strong> :&ensp;<code>float [K]</code></dt>
<dd>Normative indoor temperature for static heat load calculation.
The input of t_inside is ALWAYS in Kelvin</dd>
<dt><strong><code>t_outside</code></strong> :&ensp;<code>float [K]</code></dt>
<dd>Normative outdoor temperature for static heat load calculation.
The input of t_inside is ALWAYS in Kelvin</dd>
<dt><strong><code>t_ground</code></strong> :&ensp;<code>float [K]</code></dt>
<dd>Temperature directly at the outer side of ground floors for static
heat load calculation.
The input of t_ground is ALWAYS in Kelvin</dd>
<dt><strong><code>density_air</code></strong> :&ensp;<code>float [kg/m3]</code></dt>
<dd>average density of the air in the thermal zone</dd>
<dt><strong><code>heat_capac_air</code></strong> :&ensp;<code>float [J/K]</code></dt>
<dd>average heat capacity of the air in the thermal zone</dd>
<dt><strong><code>lca_data</code></strong> :&ensp;<code>En15804LcaData</code></dt>
<dd>enviromental indicator of the thermalzone. The data referencing to
one thermalzone</dd>
</dl>
<p>Constructor for ThermalZone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThermalZone(object):
    &#34;&#34;&#34;Thermal zone class.

    This class is used to manage information and parameter calculation for
    thermal zones. Each thermal zone has one specific calculation method,
    which is specific to the used model (model_attr). For new model
    implementation this attribute can be assigned to new classes.

    Parameters
    ----------
    parent: Building()
        The parent class of this object, the Building the zone belongs to.
        Allows for better control of hierarchical structures. If not None it
        adds this ThermalZone instance to Building.thermal_zones.
        Default is None

    Attributes
    ----------

    internal_id : float
        Random id for the distinction between different zones.
    name : str
        Individual name.
    area : float [m2]
        Thermal zone area.
    volume : float [m3]
        Thermal zone volume.
    outer_walls : list
        List of OuterWall instances.
    doors : list
        List of Door instances.
    rooftops : list
        List of Rooftop instances.
    ground_floors : list
        List of GroundFloor instances.
    windows : list
        List of Window instances.
    inner_walls : list
        List of InnerWall instances.
    floors : list
        List of Floor instances.
    ceilings: list
        List of Ceiling instances.
    use_conditions : instance of UseConditions()
        Instance of UseConditions with all relevant information for the usage
        of the thermal zone
    model_attr : instance of OneElement(), TwoElement(), ThreeElement() or
                FourElement()
        Instance of OneElement(), TwoElement(), ThreeElement() or
        FourElement(), that holds all calculation functions and attributes
        needed for the specific model.
    t_inside : float [K]
        Normative indoor temperature for static heat load calculation.
        The input of t_inside is ALWAYS in Kelvin
    t_outside : float [K]
        Normative outdoor temperature for static heat load calculation.
        The input of t_inside is ALWAYS in Kelvin
    t_ground : float [K]
        Temperature directly at the outer side of ground floors for static
        heat load calculation.
        The input of t_ground is ALWAYS in Kelvin
    density_air : float [kg/m3]
        average density of the air in the thermal zone
    heat_capac_air : float [J/K]
        average heat capacity of the air in the thermal zone
    
    lca_data : En15804LcaData
        enviromental indicator of the thermalzone. The data referencing to
        one thermalzone
    &#34;&#34;&#34;

    def __init__(self, parent=None):
        &#34;&#34;&#34;Constructor for ThermalZone
        &#34;&#34;&#34;

        self.parent = parent

        self.internal_id = uuid.uuid1()
        self.name = None
        self._area = None
        self._volume = None
        self._infiltration_rate = 0.4
        self._outer_walls = []
        self._doors = []
        self._rooftops = []
        self._ground_floors = []
        self._windows = []
        self._inner_walls = []
        self._floors = []
        self._ceilings = []
        self._use_conditions = None
        self._t_inside = 293.15
        self._t_outside = 261.15
        self.density_air = 1.25
        self.heat_capac_air = 1002
        self.t_ground = 286.15
        
        self._lca_data = None

    def calc_zone_parameters(
            self,
            number_of_elements=2,
            merge_windows=False,
            t_bt=5):
        &#34;&#34;&#34;RC-Calculation for the thermal zone

        Based on the input parameters (used model) this function instantiates
        the corresponding calculation Class (e.g. TwoElement) and calculates
        the zone parameters. Currently the function is able to distinguishes
        between the number of elements, we distinguish between:
            - one element: all outer walls are aggregated into one element,
            inner wall are neglected
            - two elements: exterior and interior walls are aggregated
            - three elements: like 2, but floor or roofs are aggregated
            separately
            - four elements: roofs and floors are aggregated separately

        For all four options we can chose if the thermal conduction through
        the window is considered in a separate resistance or not.

        Parameters
        ----------
        number_of_elements : int
            defines the number of elements, that area aggregated, between 1
            and 4, default is 2

        merge_windows : bool
            True for merging the windows into the outer walls, False for
            separate resistance for window, default is False (Only
            supported for IBPSA)

        t_bt : float
            Time constant according to VDI 6007 (default t_bt = 5)
        &#34;&#34;&#34;

        if number_of_elements == 1:
            self.model_attr = OneElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()
        elif number_of_elements == 2:
            self.model_attr = TwoElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()
        elif number_of_elements == 3:
            self.model_attr = ThreeElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()
        elif number_of_elements == 4:
            self.model_attr = FourElement(
                thermal_zone=self,
                merge_windows=merge_windows,
                t_bt=t_bt)
            self.model_attr.calc_attributes()

    def find_walls(self, orientation, tilt):
        &#34;&#34;&#34;Returns all outer walls with given orientation and tilt

        This function returns a list of all OuterWall elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired walls.
        tilt : float [degree]
            Tilt against the horizontal of the desired walls.

        Returns
        -------
        elements : list
            List of OuterWalls instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.outer_walls:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_doors(self, orientation, tilt):
        &#34;&#34;&#34;Returns all outer walls with given orientation and tilt

        This function returns a list of all Doors elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired walls.
        tilt : float [degree]
            Tilt against the horizontal of the desired walls.

        Returns
        -------
        elements : list
            List of Doors instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.doors:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_rts(self, orientation, tilt):
        &#34;&#34;&#34;Returns all rooftops with given orientation and tilt

        This function returns a list of all Rooftop elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired rooftops.
        tilt : float [degree]
            Tilt against the horizontal of the desired rooftops.

        Returns
        -------
        elements : list
            List of Rooftop instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.rooftops:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_gfs(self, orientation, tilt):
        &#34;&#34;&#34;Returns all ground floors with given orientation and tilt

        This function returns a list of all GroundFloor elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired ground floors.
        tilt : float [degree]
            Tilt against the horizontal of the desired ground floors.

        Returns
        -------
        elements : list
            List of GroundFloor instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.ground_floors:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def find_wins(self, orientation, tilt):
        &#34;&#34;&#34;Returns all windows with given orientation and tilt

        This function returns a list of all Window elements with the
        same orientation and tilt.

        Parameters
        ----------
        orientation : float [degree]
            Azimuth of the desired windows.
        tilt : float [degree]
            Tilt against the horizontal of the desired windows.

        Returns
        -------
        elements : list
            List of Window instances with desired orientation and tilt.
        &#34;&#34;&#34;
        elements = []
        for i in self.windows:
            if i.orientation == orientation and i.tilt == tilt:
                elements.append(i)
            else:
                pass
        return elements

    def set_inner_wall_area(self):
        &#34;&#34;&#34;Sets the inner wall area according to zone area

        Sets the inner wall area according to zone area size if type building
        approach is used. This function covers Floors, Ceilings and InnerWalls.
        &#34;&#34;&#34;

        ass_error_1 = &#34;You need to specify parent for thermal zone&#34;

        assert self.parent is not None, ass_error_1

        for floor in self.floors:
            floor.area = (
                (self.parent.number_of_floors - 1) /
                self.parent.number_of_floors) * self.area
        for ceiling in self.ceilings:
            ceiling.area = (
                (self.parent.number_of_floors - 1) /
                self.parent.number_of_floors) * self.area

        for wall in self.inner_walls:
            typical_area = self.use_conditions.typical_length * \
                self.use_conditions.typical_width

            avg_room_nr = self.area / typical_area

            wall.area = (avg_room_nr * (self.use_conditions.typical_length *
                                        self.parent.height_of_floors +
                                        2 * self.use_conditions.typical_width *
                                        self.parent.height_of_floors))

    def set_volume_zone(self):
        &#34;&#34;&#34;Sets the zone volume according to area and height of floors

        Sets the volume of a zone according area and height of floors
        (building attribute).
        &#34;&#34;&#34;

        ass_error_1 = &#34;you need to specify parent for thermal zone&#34;

        assert self.parent is not None, ass_error_1

        self.volume = self.area * self.parent.height_of_floors

    def retrofit_zone(
            self,
            type_of_retrofit=None,
            window_type=None,
            material=None):
        &#34;&#34;&#34;Retrofits all walls and windows in the zone.

        Function call for all elements facing the ambient or ground.
        Distinguishes if the parent building is a archetype of type &#39;iwu&#39; or
        &#39;tabula_de&#39;. If TABULA is used, it will use the pre-defined wall
        constructions of TABULA.

        This function covers OuterWall, Rooftop, GroundFloor and Window.

        Parameters
        ----------
        type_of_retrofit : str
            The classification of retrofit, if the archetype building
            approach of TABULA is used.
        window_type : str
            Default: EnEv 2014
        material : str
            Default: EPS035
        &#34;&#34;&#34;

        if type_of_retrofit is None:
            type_of_retrofit = &#39;retrofit&#39;

        if type(self.parent).__name__ in [
            &#34;SingleFamilyHouse&#34;, &#34;TerracedHouse&#34;, &#34;MultiFamilyHouse&#34;,
                &#34;ApartmentBlock&#34;]:
            for wall_count in self.outer_walls \
                    + self.rooftops + self.ground_floors + self.doors + \
                    self.windows:
                if &#34;adv_retrofit&#34; in wall_count.construction_type:
                    warnings.warn(
                        &#34;already highest available standard&#34;
                        + self.parent.name + wall_count.name)
                elif &#34;standard&#34; in wall_count.construction_type:
                    wall_count.load_type_element(
                        year=self.parent.year_of_construction,
                        construction=wall_count.construction_type.replace(
                            &#34;standard&#34;, type_of_retrofit))
                else:
                    wall_count.load_type_element(
                        year=self.parent.year_of_construction,
                        construction=wall_count.construction_type.replace(
                            &#34;retrofit&#34;, type_of_retrofit))
        else:

            for wall_count in self.outer_walls:
                wall_count.retrofit_wall(
                    self.parent.year_of_retrofit,
                    material)
            for roof_count in self.rooftops:
                roof_count.retrofit_wall(
                    self.parent.year_of_retrofit,
                    material)
            for ground_count in self.ground_floors:
                ground_count.retrofit_wall(
                    self.parent.year_of_retrofit,
                    material)
            for win_count in self.windows:
                win_count.replace_window(
                    self.parent.year_of_retrofit,
                    window_type)

    def delete(self):
        &#34;&#34;&#34;Deletes the actual thermal zone safely.

        This deletes the current thermal Zone and also refreshes the
        thermal_zones list in the parent Building.
        &#34;&#34;&#34;
        for index, tz in enumerate(self.parent.thermal_zones):
            if tz.internal_id == self.internal_id:
                self.parent.net_leased_area -= self.area
                self.parent.thermal_zones.pop(index)

                break

    def add_element(self, building_element):
        &#34;&#34;&#34;Adds a building element to the corresponding list

        This function adds a BuildingElement instance to the the list
        depending on the type of the Building Element

        Parameters
        ----------
        building_element : BuildingElement()
            inherited objects of BuildingElement() instance of TEASER

        &#34;&#34;&#34;

        ass_error_1 = (&#34;building_element has to be an instance of OuterWall,&#34;
                       &#34; Rooftop, GroundFloor, Window, InnerWall, &#34;
                       &#34;Ceiling or Floor&#34;)

        assert type(building_element).__name__ in (
            &#34;OuterWall&#34;, &#34;Rooftop&#34;, &#34;GroundFloor&#34;,
            &#34;InnerWall&#34;, &#34;Ceiling&#34;, &#34;Floor&#34;,
            &#34;Window&#34;), ass_error_1

        if type(building_element).__name__ == &#34;OuterWall&#34;:
            self._outer_walls.append(building_element)
        elif type(building_element).__name__ == &#34;GroundFloor&#34;:
            self._ground_floors.append(building_element)
        elif type(building_element).__name__ == &#34;Rooftop&#34;:
            self._rooftops.append(building_element)
        elif type(building_element).__name__ == &#34;InnerWall&#34;:
            self._inner_walls.append(building_element)
        elif type(building_element).__name__ == &#34;Ceiling&#34;:
            self._ceilings.append(building_element)
        elif type(building_element).__name__ == &#34;Floor&#34;:
            self._floors.append(building_element)
        elif type(building_element).__name__ == &#34;Window&#34;:
            self._windows.append(building_element)

    @property
    def parent(self):
        return self.__parent

    @parent.setter
    def parent(self, value):
        from teaser.logic.buildingobjects.building import Building
        import inspect
        if value is not None:
            if inspect.isclass(Building):
                self.__parent = value
                self.__parent.thermal_zones.append(self)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            regex = re.compile(&#39;[^a-zA-z0-9]&#39;)
            self._name = regex.sub(&#39;&#39;, value)
        else:
            try:
                value = str(value)
                regex = re.compile(&#39;[^a-zA-z0-9]&#39;)
                self._name = regex.sub(&#39;&#39;, value)

            except ValueError:
                print(&#34;Can&#39;t convert name to string&#34;)

    @property
    def outer_walls(self):
        return self._outer_walls

    @outer_walls.setter
    def outer_walls(self, value):
        if value is None:
            self._outer_walls = []

    @property
    def doors(self):
        return self._doors

    @doors.setter
    def doors(self, value):
        if value is None:
            self._doors = []

    @property
    def rooftops(self):
        return self._rooftops

    @rooftops.setter
    def rooftops(self, value):
        if value is None:
            self._rooftops = []

    @property
    def ground_floors(self):
        return self._ground_floors

    @ground_floors.setter
    def ground_floors(self, value):
        if value is None:
            self._ground_floors = []

    @property
    def ceilings(self):
        return self._ceilings

    @ceilings.setter
    def ceilings(self, value):
        if value is None:
            self._ceilings = []

    @property
    def floors(self):
        return self._floors

    @floors.setter
    def floors(self, value):
        if value is None:
            self._floors = []

    @property
    def inner_walls(self):
        return self._inner_walls

    @inner_walls.setter
    def inner_walls(self, value):

        if value is None:
            self._inner_walls = []

    @property
    def windows(self):
        return self._windows

    @windows.setter
    def windows(self, value):

        if value is None:
            self._windows = []

    @property
    def use_conditions(self):
        return self._use_conditions

    @use_conditions.setter
    def use_conditions(self, value):
        ass_error_1 = &#34;Use condition has to be an instance of UseConditions()&#34;

        assert type(value).__name__ == &#34;UseConditions&#34;, ass_error_1

        if value is not None:
            self._use_conditions = value
            self.typical_length = value.typical_length
            self.typical_width = value.typical_width
        self._use_conditions = value

    @property
    def area(self):
        return self._area

    @area.setter
    def area(self, value):

        if isinstance(value, float):
            pass
        elif value is None:
            pass
        else:
            try:
                value = float(value)
            except:
                raise ValueError(&#34;Can&#39;t convert zone area to float&#34;)

        if self.parent is not None:
            if self._area is None:
                if self.parent.net_leased_area is None:
                    self.parent.net_leased_area = 0.0
                self._area = value
                self.parent.net_leased_area += value
            else:
                self.parent.net_leased_area -= self._area
                self.parent.net_leased_area += value
                self._area = value
        else:
            self._area = value

    @property
    def volume(self):
        return self._volume

    @volume.setter
    def volume(self, value):

        if isinstance(value, float):
            pass
        elif value is None:
            pass
        else:
            try:
                value = float(value)
            except ValueError:
                raise ValueError(&#34;Can&#39;t convert zone volume to float&#34;)

        if self.parent is not None:
            if self._volume is None:
                self._volume = value
                self.parent.volume += value
            else:
                self.parent.volume -= self._volume
                self.parent.volume += value
                self._volume = value
        else:
            self._volume = value

    @property
    def infiltration_rate(self):
        warnings.warn(
            &#34;Deprecated for ThermalZone, moved to UseConditions&#34;,
            DeprecationWarning)

    @infiltration_rate.setter
    def infiltration_rate(self, value):
        warnings.warn(
            &#34;Deprecated for ThermalZone, moved to UseConditions&#34;,
            DeprecationWarning)

    @property
    def t_inside(self):
        return self._t_inside

    @t_inside.setter
    def t_inside(self, value):
        if isinstance(value, float):
            self._t_inside = value
        elif value is None:
            self._t_inside = value
        else:
            try:
                value = float(value)
                self._t_inside = value
            except:
                raise ValueError(&#34;Can&#39;t convert temperature to float&#34;)

    @property
    def t_outside(self):
        return self._t_outside

    @t_outside.setter
    def t_outside(self, value):

        if isinstance(value, float):
            self._t_outside = value
        elif value is None:
            self._t_outside = value
        else:
            try:
                value = float(value)
                self._t_outside = value
            except:
                raise ValueError(&#34;Can&#39;t convert temperature to float&#34;)
                
    @property
    def lca_data(self):
        return self._lca_data

    @lca_data.setter
    def lca_data(self, value):
        self._lca_data = value
        
    def get_buildingelements(self):
        &#34;&#34;&#34;returns a list of all buildingelements of the thermalzone
        

        Returns
        -------
        building_elements : list

        &#34;&#34;&#34;
        building_elements = []
        
        building_elements.extend(self.outer_walls)
        building_elements.extend(self.ground_floors)
        building_elements.extend(self.rooftops)
        building_elements.extend(self.inner_walls)
        building_elements.extend(self.floors)
        building_elements.extend(self.windows)
        building_elements.extend(self.ceilings)
        
        return building_elements

    def calc_lca_data(self, use_b4 = None, period_lca_scenario = None):
        &#34;&#34;&#34;sums up every LCA-data from building elements oft he thermalzone.
 
    
        Parameters
        ----------
        use_b4 : bool, optional
            if true all replaced materials and building elements are added to
            stage B4. The default is None.
        period_lca_scenario : int [a], optional
            period of use taken into account for LCA.

        &#34;&#34;&#34;
        lca_data = En15804LcaData()
        
        if use_b4 is None:
            try:
                use_b4 = self.parent.parent.parent.use_b4
            except:
                use_b4 = False
        
        if period_lca_scenario == None:
            try:
                period_lca_scenario = self.parent.parent.parent.period_lca_scenario
            except:
                print(&#34;Please enter a period for the LCA-scenario!&#34;)
                
        building_elements = self.get_buildingelements()
        
        for building_element in building_elements:

            try:
                building_element.calc_lca_data(use_b4, period_lca_scenario)
                lca_data = lca_data + building_element.lca_data
            except:
                print(&#34;Error while adding {}&#34;.format(type(building_element).__name__))
            
        self.lca_data = lca_data</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.area"><code class="name">var <span class="ident">area</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def area(self):
    return self._area</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.ceilings"><code class="name">var <span class="ident">ceilings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ceilings(self):
    return self._ceilings</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.doors"><code class="name">var <span class="ident">doors</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def doors(self):
    return self._doors</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.floors"><code class="name">var <span class="ident">floors</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def floors(self):
    return self._floors</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.ground_floors"><code class="name">var <span class="ident">ground_floors</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ground_floors(self):
    return self._ground_floors</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.infiltration_rate"><code class="name">var <span class="ident">infiltration_rate</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def infiltration_rate(self):
    warnings.warn(
        &#34;Deprecated for ThermalZone, moved to UseConditions&#34;,
        DeprecationWarning)</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.inner_walls"><code class="name">var <span class="ident">inner_walls</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inner_walls(self):
    return self._inner_walls</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.lca_data"><code class="name">var <span class="ident">lca_data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lca_data(self):
    return self._lca_data</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.outer_walls"><code class="name">var <span class="ident">outer_walls</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outer_walls(self):
    return self._outer_walls</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    return self.__parent</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.rooftops"><code class="name">var <span class="ident">rooftops</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rooftops(self):
    return self._rooftops</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.t_inside"><code class="name">var <span class="ident">t_inside</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def t_inside(self):
    return self._t_inside</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.t_outside"><code class="name">var <span class="ident">t_outside</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def t_outside(self):
    return self._t_outside</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.use_conditions"><code class="name">var <span class="ident">use_conditions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def use_conditions(self):
    return self._use_conditions</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.volume"><code class="name">var <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self):
    return self._volume</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.windows"><code class="name">var <span class="ident">windows</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def windows(self):
    return self._windows</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.add_element"><code class="name flex">
<span>def <span class="ident">add_element</span></span>(<span>self, building_element)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a building element to the corresponding list</p>
<p>This function adds a BuildingElement instance to the the list
depending on the type of the Building Element</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>building_element</code></strong> :&ensp;<code>BuildingElement()</code></dt>
<dd>inherited objects of BuildingElement() instance of TEASER</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_element(self, building_element):
    &#34;&#34;&#34;Adds a building element to the corresponding list

    This function adds a BuildingElement instance to the the list
    depending on the type of the Building Element

    Parameters
    ----------
    building_element : BuildingElement()
        inherited objects of BuildingElement() instance of TEASER

    &#34;&#34;&#34;

    ass_error_1 = (&#34;building_element has to be an instance of OuterWall,&#34;
                   &#34; Rooftop, GroundFloor, Window, InnerWall, &#34;
                   &#34;Ceiling or Floor&#34;)

    assert type(building_element).__name__ in (
        &#34;OuterWall&#34;, &#34;Rooftop&#34;, &#34;GroundFloor&#34;,
        &#34;InnerWall&#34;, &#34;Ceiling&#34;, &#34;Floor&#34;,
        &#34;Window&#34;), ass_error_1

    if type(building_element).__name__ == &#34;OuterWall&#34;:
        self._outer_walls.append(building_element)
    elif type(building_element).__name__ == &#34;GroundFloor&#34;:
        self._ground_floors.append(building_element)
    elif type(building_element).__name__ == &#34;Rooftop&#34;:
        self._rooftops.append(building_element)
    elif type(building_element).__name__ == &#34;InnerWall&#34;:
        self._inner_walls.append(building_element)
    elif type(building_element).__name__ == &#34;Ceiling&#34;:
        self._ceilings.append(building_element)
    elif type(building_element).__name__ == &#34;Floor&#34;:
        self._floors.append(building_element)
    elif type(building_element).__name__ == &#34;Window&#34;:
        self._windows.append(building_element)</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.calc_lca_data"><code class="name flex">
<span>def <span class="ident">calc_lca_data</span></span>(<span>self, use_b4=None, period_lca_scenario=None)</span>
</code></dt>
<dd>
<div class="desc"><p>sums up every LCA-data from building elements oft he thermalzone.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>use_b4</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if true all replaced materials and building elements are added to
stage B4. The default is None.</dd>
<dt><strong><code>period_lca_scenario</code></strong> :&ensp;<code>int [a]</code>, optional</dt>
<dd>period of use taken into account for LCA.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_lca_data(self, use_b4 = None, period_lca_scenario = None):
    &#34;&#34;&#34;sums up every LCA-data from building elements oft he thermalzone.


    Parameters
    ----------
    use_b4 : bool, optional
        if true all replaced materials and building elements are added to
        stage B4. The default is None.
    period_lca_scenario : int [a], optional
        period of use taken into account for LCA.

    &#34;&#34;&#34;
    lca_data = En15804LcaData()
    
    if use_b4 is None:
        try:
            use_b4 = self.parent.parent.parent.use_b4
        except:
            use_b4 = False
    
    if period_lca_scenario == None:
        try:
            period_lca_scenario = self.parent.parent.parent.period_lca_scenario
        except:
            print(&#34;Please enter a period for the LCA-scenario!&#34;)
            
    building_elements = self.get_buildingelements()
    
    for building_element in building_elements:

        try:
            building_element.calc_lca_data(use_b4, period_lca_scenario)
            lca_data = lca_data + building_element.lca_data
        except:
            print(&#34;Error while adding {}&#34;.format(type(building_element).__name__))
        
    self.lca_data = lca_data</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.calc_zone_parameters"><code class="name flex">
<span>def <span class="ident">calc_zone_parameters</span></span>(<span>self, number_of_elements=2, merge_windows=False, t_bt=5)</span>
</code></dt>
<dd>
<div class="desc"><p>RC-Calculation for the thermal zone</p>
<p>Based on the input parameters (used model) this function instantiates
the corresponding calculation Class (e.g. TwoElement) and calculates
the zone parameters. Currently the function is able to distinguishes
between the number of elements, we distinguish between:
- one element: all outer walls are aggregated into one element,
inner wall are neglected
- two elements: exterior and interior walls are aggregated
- three elements: like 2, but floor or roofs are aggregated
separately
- four elements: roofs and floors are aggregated separately</p>
<p>For all four options we can chose if the thermal conduction through
the window is considered in a separate resistance or not.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>number_of_elements</code></strong> :&ensp;<code>int</code></dt>
<dd>defines the number of elements, that area aggregated, between 1
and 4, default is 2</dd>
<dt><strong><code>merge_windows</code></strong> :&ensp;<code>bool</code></dt>
<dd>True for merging the windows into the outer walls, False for
separate resistance for window, default is False (Only
supported for IBPSA)</dd>
<dt><strong><code>t_bt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time constant according to VDI 6007 (default t_bt = 5)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_zone_parameters(
        self,
        number_of_elements=2,
        merge_windows=False,
        t_bt=5):
    &#34;&#34;&#34;RC-Calculation for the thermal zone

    Based on the input parameters (used model) this function instantiates
    the corresponding calculation Class (e.g. TwoElement) and calculates
    the zone parameters. Currently the function is able to distinguishes
    between the number of elements, we distinguish between:
        - one element: all outer walls are aggregated into one element,
        inner wall are neglected
        - two elements: exterior and interior walls are aggregated
        - three elements: like 2, but floor or roofs are aggregated
        separately
        - four elements: roofs and floors are aggregated separately

    For all four options we can chose if the thermal conduction through
    the window is considered in a separate resistance or not.

    Parameters
    ----------
    number_of_elements : int
        defines the number of elements, that area aggregated, between 1
        and 4, default is 2

    merge_windows : bool
        True for merging the windows into the outer walls, False for
        separate resistance for window, default is False (Only
        supported for IBPSA)

    t_bt : float
        Time constant according to VDI 6007 (default t_bt = 5)
    &#34;&#34;&#34;

    if number_of_elements == 1:
        self.model_attr = OneElement(
            thermal_zone=self,
            merge_windows=merge_windows,
            t_bt=t_bt)
        self.model_attr.calc_attributes()
    elif number_of_elements == 2:
        self.model_attr = TwoElement(
            thermal_zone=self,
            merge_windows=merge_windows,
            t_bt=t_bt)
        self.model_attr.calc_attributes()
    elif number_of_elements == 3:
        self.model_attr = ThreeElement(
            thermal_zone=self,
            merge_windows=merge_windows,
            t_bt=t_bt)
        self.model_attr.calc_attributes()
    elif number_of_elements == 4:
        self.model_attr = FourElement(
            thermal_zone=self,
            merge_windows=merge_windows,
            t_bt=t_bt)
        self.model_attr.calc_attributes()</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the actual thermal zone safely.</p>
<p>This deletes the current thermal Zone and also refreshes the
thermal_zones list in the parent Building.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    &#34;&#34;&#34;Deletes the actual thermal zone safely.

    This deletes the current thermal Zone and also refreshes the
    thermal_zones list in the parent Building.
    &#34;&#34;&#34;
    for index, tz in enumerate(self.parent.thermal_zones):
        if tz.internal_id == self.internal_id:
            self.parent.net_leased_area -= self.area
            self.parent.thermal_zones.pop(index)

            break</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_doors"><code class="name flex">
<span>def <span class="ident">find_doors</span></span>(<span>self, orientation, tilt)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all outer walls with given orientation and tilt</p>
<p>This function returns a list of all Doors elements with the
same orientation and tilt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Azimuth of the desired walls.</dd>
<dt><strong><code>tilt</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Tilt against the horizontal of the desired walls.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Doors instances with desired orientation and tilt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_doors(self, orientation, tilt):
    &#34;&#34;&#34;Returns all outer walls with given orientation and tilt

    This function returns a list of all Doors elements with the
    same orientation and tilt.

    Parameters
    ----------
    orientation : float [degree]
        Azimuth of the desired walls.
    tilt : float [degree]
        Tilt against the horizontal of the desired walls.

    Returns
    -------
    elements : list
        List of Doors instances with desired orientation and tilt.
    &#34;&#34;&#34;
    elements = []
    for i in self.doors:
        if i.orientation == orientation and i.tilt == tilt:
            elements.append(i)
        else:
            pass
    return elements</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_gfs"><code class="name flex">
<span>def <span class="ident">find_gfs</span></span>(<span>self, orientation, tilt)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all ground floors with given orientation and tilt</p>
<p>This function returns a list of all GroundFloor elements with the
same orientation and tilt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Azimuth of the desired ground floors.</dd>
<dt><strong><code>tilt</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Tilt against the horizontal of the desired ground floors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>list</code></dt>
<dd>List of GroundFloor instances with desired orientation and tilt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_gfs(self, orientation, tilt):
    &#34;&#34;&#34;Returns all ground floors with given orientation and tilt

    This function returns a list of all GroundFloor elements with the
    same orientation and tilt.

    Parameters
    ----------
    orientation : float [degree]
        Azimuth of the desired ground floors.
    tilt : float [degree]
        Tilt against the horizontal of the desired ground floors.

    Returns
    -------
    elements : list
        List of GroundFloor instances with desired orientation and tilt.
    &#34;&#34;&#34;
    elements = []
    for i in self.ground_floors:
        if i.orientation == orientation and i.tilt == tilt:
            elements.append(i)
        else:
            pass
    return elements</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_rts"><code class="name flex">
<span>def <span class="ident">find_rts</span></span>(<span>self, orientation, tilt)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all rooftops with given orientation and tilt</p>
<p>This function returns a list of all Rooftop elements with the
same orientation and tilt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Azimuth of the desired rooftops.</dd>
<dt><strong><code>tilt</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Tilt against the horizontal of the desired rooftops.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Rooftop instances with desired orientation and tilt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_rts(self, orientation, tilt):
    &#34;&#34;&#34;Returns all rooftops with given orientation and tilt

    This function returns a list of all Rooftop elements with the
    same orientation and tilt.

    Parameters
    ----------
    orientation : float [degree]
        Azimuth of the desired rooftops.
    tilt : float [degree]
        Tilt against the horizontal of the desired rooftops.

    Returns
    -------
    elements : list
        List of Rooftop instances with desired orientation and tilt.
    &#34;&#34;&#34;
    elements = []
    for i in self.rooftops:
        if i.orientation == orientation and i.tilt == tilt:
            elements.append(i)
        else:
            pass
    return elements</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_walls"><code class="name flex">
<span>def <span class="ident">find_walls</span></span>(<span>self, orientation, tilt)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all outer walls with given orientation and tilt</p>
<p>This function returns a list of all OuterWall elements with the
same orientation and tilt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Azimuth of the desired walls.</dd>
<dt><strong><code>tilt</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Tilt against the horizontal of the desired walls.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>list</code></dt>
<dd>List of OuterWalls instances with desired orientation and tilt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_walls(self, orientation, tilt):
    &#34;&#34;&#34;Returns all outer walls with given orientation and tilt

    This function returns a list of all OuterWall elements with the
    same orientation and tilt.

    Parameters
    ----------
    orientation : float [degree]
        Azimuth of the desired walls.
    tilt : float [degree]
        Tilt against the horizontal of the desired walls.

    Returns
    -------
    elements : list
        List of OuterWalls instances with desired orientation and tilt.
    &#34;&#34;&#34;
    elements = []
    for i in self.outer_walls:
        if i.orientation == orientation and i.tilt == tilt:
            elements.append(i)
        else:
            pass
    return elements</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_wins"><code class="name flex">
<span>def <span class="ident">find_wins</span></span>(<span>self, orientation, tilt)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all windows with given orientation and tilt</p>
<p>This function returns a list of all Window elements with the
same orientation and tilt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Azimuth of the desired windows.</dd>
<dt><strong><code>tilt</code></strong> :&ensp;<code>float [degree]</code></dt>
<dd>Tilt against the horizontal of the desired windows.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Window instances with desired orientation and tilt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_wins(self, orientation, tilt):
    &#34;&#34;&#34;Returns all windows with given orientation and tilt

    This function returns a list of all Window elements with the
    same orientation and tilt.

    Parameters
    ----------
    orientation : float [degree]
        Azimuth of the desired windows.
    tilt : float [degree]
        Tilt against the horizontal of the desired windows.

    Returns
    -------
    elements : list
        List of Window instances with desired orientation and tilt.
    &#34;&#34;&#34;
    elements = []
    for i in self.windows:
        if i.orientation == orientation and i.tilt == tilt:
            elements.append(i)
        else:
            pass
    return elements</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.get_buildingelements"><code class="name flex">
<span>def <span class="ident">get_buildingelements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a list of all buildingelements of the thermalzone</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>building_elements</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buildingelements(self):
    &#34;&#34;&#34;returns a list of all buildingelements of the thermalzone
    

    Returns
    -------
    building_elements : list

    &#34;&#34;&#34;
    building_elements = []
    
    building_elements.extend(self.outer_walls)
    building_elements.extend(self.ground_floors)
    building_elements.extend(self.rooftops)
    building_elements.extend(self.inner_walls)
    building_elements.extend(self.floors)
    building_elements.extend(self.windows)
    building_elements.extend(self.ceilings)
    
    return building_elements</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.retrofit_zone"><code class="name flex">
<span>def <span class="ident">retrofit_zone</span></span>(<span>self, type_of_retrofit=None, window_type=None, material=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrofits all walls and windows in the zone.</p>
<p>Function call for all elements facing the ambient or ground.
Distinguishes if the parent building is a archetype of type 'iwu' or
'tabula_de'. If TABULA is used, it will use the pre-defined wall
constructions of TABULA.</p>
<p>This function covers OuterWall, Rooftop, GroundFloor and Window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_of_retrofit</code></strong> :&ensp;<code>str</code></dt>
<dd>The classification of retrofit, if the archetype building
approach of TABULA is used.</dd>
<dt><strong><code>window_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Default: EnEv 2014</dd>
<dt><strong><code>material</code></strong> :&ensp;<code>str</code></dt>
<dd>Default: EPS035</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrofit_zone(
        self,
        type_of_retrofit=None,
        window_type=None,
        material=None):
    &#34;&#34;&#34;Retrofits all walls and windows in the zone.

    Function call for all elements facing the ambient or ground.
    Distinguishes if the parent building is a archetype of type &#39;iwu&#39; or
    &#39;tabula_de&#39;. If TABULA is used, it will use the pre-defined wall
    constructions of TABULA.

    This function covers OuterWall, Rooftop, GroundFloor and Window.

    Parameters
    ----------
    type_of_retrofit : str
        The classification of retrofit, if the archetype building
        approach of TABULA is used.
    window_type : str
        Default: EnEv 2014
    material : str
        Default: EPS035
    &#34;&#34;&#34;

    if type_of_retrofit is None:
        type_of_retrofit = &#39;retrofit&#39;

    if type(self.parent).__name__ in [
        &#34;SingleFamilyHouse&#34;, &#34;TerracedHouse&#34;, &#34;MultiFamilyHouse&#34;,
            &#34;ApartmentBlock&#34;]:
        for wall_count in self.outer_walls \
                + self.rooftops + self.ground_floors + self.doors + \
                self.windows:
            if &#34;adv_retrofit&#34; in wall_count.construction_type:
                warnings.warn(
                    &#34;already highest available standard&#34;
                    + self.parent.name + wall_count.name)
            elif &#34;standard&#34; in wall_count.construction_type:
                wall_count.load_type_element(
                    year=self.parent.year_of_construction,
                    construction=wall_count.construction_type.replace(
                        &#34;standard&#34;, type_of_retrofit))
            else:
                wall_count.load_type_element(
                    year=self.parent.year_of_construction,
                    construction=wall_count.construction_type.replace(
                        &#34;retrofit&#34;, type_of_retrofit))
    else:

        for wall_count in self.outer_walls:
            wall_count.retrofit_wall(
                self.parent.year_of_retrofit,
                material)
        for roof_count in self.rooftops:
            roof_count.retrofit_wall(
                self.parent.year_of_retrofit,
                material)
        for ground_count in self.ground_floors:
            ground_count.retrofit_wall(
                self.parent.year_of_retrofit,
                material)
        for win_count in self.windows:
            win_count.replace_window(
                self.parent.year_of_retrofit,
                window_type)</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.set_inner_wall_area"><code class="name flex">
<span>def <span class="ident">set_inner_wall_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the inner wall area according to zone area</p>
<p>Sets the inner wall area according to zone area size if type building
approach is used. This function covers Floors, Ceilings and InnerWalls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_inner_wall_area(self):
    &#34;&#34;&#34;Sets the inner wall area according to zone area

    Sets the inner wall area according to zone area size if type building
    approach is used. This function covers Floors, Ceilings and InnerWalls.
    &#34;&#34;&#34;

    ass_error_1 = &#34;You need to specify parent for thermal zone&#34;

    assert self.parent is not None, ass_error_1

    for floor in self.floors:
        floor.area = (
            (self.parent.number_of_floors - 1) /
            self.parent.number_of_floors) * self.area
    for ceiling in self.ceilings:
        ceiling.area = (
            (self.parent.number_of_floors - 1) /
            self.parent.number_of_floors) * self.area

    for wall in self.inner_walls:
        typical_area = self.use_conditions.typical_length * \
            self.use_conditions.typical_width

        avg_room_nr = self.area / typical_area

        wall.area = (avg_room_nr * (self.use_conditions.typical_length *
                                    self.parent.height_of_floors +
                                    2 * self.use_conditions.typical_width *
                                    self.parent.height_of_floors))</code></pre>
</details>
</dd>
<dt id="teaser.logic.buildingobjects.thermalzone.ThermalZone.set_volume_zone"><code class="name flex">
<span>def <span class="ident">set_volume_zone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the zone volume according to area and height of floors</p>
<p>Sets the volume of a zone according area and height of floors
(building attribute).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_volume_zone(self):
    &#34;&#34;&#34;Sets the zone volume according to area and height of floors

    Sets the volume of a zone according area and height of floors
    (building attribute).
    &#34;&#34;&#34;

    ass_error_1 = &#34;you need to specify parent for thermal zone&#34;

    assert self.parent is not None, ass_error_1

    self.volume = self.area * self.parent.height_of_floors</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="teaser.logic.buildingobjects" href="index.html">teaser.logic.buildingobjects</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone">ThermalZone</a></code></h4>
<ul class="">
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.add_element" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.add_element">add_element</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.area" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.area">area</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.calc_lca_data" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.calc_lca_data">calc_lca_data</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.calc_zone_parameters" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.calc_zone_parameters">calc_zone_parameters</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.ceilings" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.ceilings">ceilings</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.delete" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.delete">delete</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.doors" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.doors">doors</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_doors" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.find_doors">find_doors</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_gfs" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.find_gfs">find_gfs</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_rts" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.find_rts">find_rts</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_walls" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.find_walls">find_walls</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.find_wins" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.find_wins">find_wins</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.floors" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.floors">floors</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.get_buildingelements" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.get_buildingelements">get_buildingelements</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.ground_floors" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.ground_floors">ground_floors</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.infiltration_rate" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.infiltration_rate">infiltration_rate</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.inner_walls" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.inner_walls">inner_walls</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.lca_data" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.lca_data">lca_data</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.name" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.name">name</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.outer_walls" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.outer_walls">outer_walls</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.parent" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.parent">parent</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.retrofit_zone" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.retrofit_zone">retrofit_zone</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.rooftops" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.rooftops">rooftops</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.set_inner_wall_area" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.set_inner_wall_area">set_inner_wall_area</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.set_volume_zone" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.set_volume_zone">set_volume_zone</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.t_inside" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.t_inside">t_inside</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.t_outside" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.t_outside">t_outside</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.use_conditions" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.use_conditions">use_conditions</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.volume" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.volume">volume</a></code></li>
<li><code><a title="teaser.logic.buildingobjects.thermalzone.ThermalZone.windows" href="#teaser.logic.buildingobjects.thermalzone.ThermalZone.windows">windows</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>